<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>H_P-&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hanspond.github.io/"/>
  <updated>2018-09-03T04:25:20.923Z</updated>
  <id>https://hanspond.github.io/</id>
  
  <author>
    <name>$H_P?</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EM Algorithm 从直观到数学理解</title>
    <link href="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20%E4%BB%8E%E7%9B%B4%E8%A7%82%E5%88%B0%E6%95%B0%E5%AD%A6%E7%90%86%E8%A7%A3/"/>
    <id>https://hanspond.github.io/2018/09/02/EM Algorithm 从直观到数学理解/</id>
    <published>2018-09-02T03:00:00.000Z</published>
    <updated>2018-09-03T04:25:20.923Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><h1 id="0x00-引言"><a href="#0x00-引言" class="headerlink" title="0x00 引言"></a>0x00 引言</h1><p>EM算法是什么？什么是E（Epectation）？什么是M（Maximization）？什么又是公式里面出现的Q函数？这些公式都是怎么推导的？Nature抛硬币的那个图怎么就看不懂嘞？为什么看了那么多文章之后还是不懂？公式的符号怎么又不一样呢？谁谁还说有九层塔？Emmm…interesting</p><p><img src="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20从直观到数学理解/WtYc-hinpmnq5181797.gif" alt=""></p><p>下面，让我们走进科学。</p><h1 id="0x10-直观理解"><a href="#0x10-直观理解" class="headerlink" title="0x10 直观理解"></a>0x10 直观理解</h1><p>现在有一个随机变量数据集$\mathbf{D}$，假设我们知道这个随机变量$\mathbf{X}$服从某种分布(一般是高斯正规分布），我们的目的是想知道这个分布的参数$\mathbf{\theta}$，可是随机变量$\mathbf{X}$里面包含不可知的参数（也就是隐变量$\mathbf{z}$）的时候，EM算法是在一边猜隐变量$\mathbf{z}$一边更新$\mathbf{\theta}$：</p><ol><li>先蒙一下目标参数$\mathbf{\theta}^{old}$</li><li>E步：利用测算的目标参数$\mathbf{\theta}^{old}$和数据集$\mathbf{D}$猜隐变量$\mathbf{z}$的分布</li><li>M步：利用上一步猜出来的隐变量$\mathbf{z}$反思更新目标参数$\mathbf{\theta}^{new}$</li><li>重复上面两步直到目标参数$\mathbf{\theta}$收缩为止</li></ol><p>再压缩成人话的话，数据集$\mathbf{D}$是以$\mathbf{z}$为比例而测出来的$\mathbf{X}$，先用$\mathbf{\theta}$蒙一个$\mathbf{z}$，然后用$\mathbf{z}$再算一个$\mathbf{\theta}$，如此反复。</p><h1 id="0x20-抛硬币的例子"><a href="#0x20-抛硬币的例子" class="headerlink" title="0x20 抛硬币的例子"></a>0x20 抛硬币的例子</h1><blockquote><p>来源：Do, C. B., &amp; Batzoglou, S. (2008). What is the expectation maximization algorithm? Nature Biotechnology, 26(8), 897–899. <a href="https://doi.org/10.1038/nbt1406" target="_blank" rel="noopener">https://doi.org/10.1038/nbt1406</a>  </p></blockquote><p><img src="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20从直观到数学理解/v2-a5b47206d802b392e0e72a23c6b7bb95_hd.jpg" alt="硬币图"></p><p>上面这篇著名的EM入门论文里面有一张很好的图例，利用抛硬币来说明EM，可是对于某些初学者来讲缺乏解读可能还是有点难理解思路。</p><p>下面尝试拆解一下分步骤解读</p><h3 id="0x21-问题定义"><a href="#0x21-问题定义" class="headerlink" title="0x21 问题定义"></a>0x21 问题定义</h3><h6 id="已知："><a href="#已知：" class="headerlink" title="已知："></a>已知：</h6><ul><li>手上有两种不同的硬币，分别称为A和B</li></ul><h6 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h6><ul><li>随机抛硬币十次为一组，记录正面朝上（H）和反面朝上（T）的数据</li><li>换硬币重复试验</li></ul><h6 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h6><ul><li>分别求这两个硬币正面朝上的概率<script type="math/tex">\theta_{A}</script>和<script type="math/tex">\theta_{B}</script></li></ul><p>&nbsp;</p><h3 id="0x22-完全信息-vs-包含隐函数的不完全信息"><a href="#0x22-完全信息-vs-包含隐函数的不完全信息" class="headerlink" title="0x22 完全信息 vs 包含隐函数的不完全信息"></a>0x22 完全信息 vs 包含隐函数的不完全信息</h3><p><img src="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20从直观到数学理解/1.PNG" alt="完全信息"></p><p>上图的实验过程中如果记录了当时抛的是A或者B哪种硬币，统计推断的时候知道了每一组是属于哪一种硬币的情况下那当然很好算，这种情况叫完全信息。</p><p><img src="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20从直观到数学理解/2.PNG" alt="不完全信息"></p><p>假如实验中根本不知道抛的时候究竟是哪一种硬币，或者就不告诉你的话，我们就没办法直接计算两种硬币正面朝上的概率了，这种情况叫不完全信息。</p><p>例如上图的数据是和完全信息的情况一样的，区别在于左边的标签是问号，不知道是什么硬币。</p><p>这个时候就用到了EM算法。</p><p>&nbsp;</p><h3 id="0x23-完全信息下的求解"><a href="#0x23-完全信息下的求解" class="headerlink" title="0x23 完全信息下的求解"></a>0x23 完全信息下的求解</h3><p><img src="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20从直观到数学理解/3.png" alt="完全信息求概率"></p><p>每次抛硬币都是独立的，从二项分布的期望公式$E[\mathbf{X}]=np$可以推导出$p=\frac{E[\mathbf{X}]}{n}=\frac{n_{ head}}{n}$。</p><ul><li><p>对于A来说，一共抛了三组共三十次，共24次向上6次向下，那么A硬币朝上的概率是$\hat \theta_{A}=\frac{24}{30}=0.8$。</p></li><li><p>对于B来说，一共抛了两组共二十次，共9次向上11次向下，那么B硬币朝上的概率是$\hat \theta_{B}=\frac{9}{30}=0.45$。</p></li></ul><p>&nbsp;</p><h3 id="0x24-不完全信息下的初级EM求解"><a href="#0x24-不完全信息下的初级EM求解" class="headerlink" title="0x24 不完全信息下的初级EM求解"></a>0x24 不完全信息下的初级EM求解</h3><p><img src="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20从直观到数学理解/2.PNG" alt="不完全信息"></p><p>不完全信息情况呢？我们根本不知道每一组的结果是属于哪种硬币的，没办法用0x24的方法算。这个时候硬币是否属于A的隐变量$z_n$是未知的。</p><p>（硬币的情况来说正常用二分法，<script type="math/tex">z_n=  \begin{cases} 1, if  \ coin \ A \\ 0, if   \ coin \ B \end{cases}</script>，不过下面使用$z_n$代表数据重新分割的时候属于A的比例。）</p><p>&nbsp;<br>&nbsp;<br>&nbsp;</p><h6 id="那怎么办？"><a href="#那怎么办？" class="headerlink" title="那怎么办？"></a>那怎么办？</h6><p>想一下就发现，一组抛多次，不同硬币的抛出不同结果的概率是相当不同的。比如说：</p><ul><li>一个$\theta=0.3$的硬币抛出4H6T的概率是$P(4H6T|\theta=0.3)=\binom{10}{4}0.3^4(1-0.3)^6=\binom{10}{4}0.0009529569$</li><li>而$\theta=0.4$的硬币抛出4H6T的概率是$P(4H6T|\theta=0.4)=\binom{10}{4}0.4^4(1-0.4)^6=\binom{10}{4}0.0011943936$</li></ul><p>也就是说，倒过来说，看到4H6T的结果的时候，这个硬币本身朝上的概率更有可能是$\theta=0.4$而不是$\theta=0.3$。</p><p>（注意有些文章里面的概率函数式子的写法用到了分号，$P(\theta;X)$，意思这是个以X为输入以$\theta$为变量的函数。为了方便，本文不使用；符号。）</p><p>所以说，已知<script type="math/tex">\theta_{A}</script>和<script type="math/tex">\theta_{B}</script>的话，我们可以通过观察抛出来的结果来推测原来硬币究竟是属于A还是B的！（这个做法叫做最大似然估计）</p><p>可是我们现在不知道<script type="math/tex">\theta_{A}</script>和<script type="math/tex">\theta_{B}</script>怎么办呢？这不是要求解的参数吗？</p><p>面对这个蛋生鸡还是鸡生蛋的cul-de-sac（死胡同），我们的做法是：先蒙一个！然后再不停互相更新修改。</p><p><img src="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20从直观到数学理解/5.png" alt="不完全信息第二步"><br>&nbsp;<br>&nbsp;<br>&nbsp;</p><h6 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h6><p>（1）先给<script type="math/tex">\theta_{A}</script>和<script type="math/tex">\theta_{B}</script>随便赋值。<br>比如<script type="math/tex">\theta_{A}^{(0)}=0.60</script>, $\theta_{B}^{(0)}=0.50$$。</p><p>（2）然后算出</p><ul><li>A硬币抛出第一组的似然函数是$P(5H5T|\theta_{A}^{(0)}=0.6)=\binom{10}{5}0.6^5(1-0.6)^5=\binom{10}{5}0.0007962624$。</li><li>B硬币抛出第一组的似然函数是$P(5H5T|\theta_{B}^{(0)}=0.5)=\binom{10}{5}0.5^5(1-0.5)^5=\binom{10}{5}0.0009765625$。</li></ul><p>由此可以看到这组比较有可能是属于A。这个例子先按照比例来把第一组数据划分给A和B。</p><ul><li>划分给A的比例是<script type="math/tex">z_1=\frac{P(5H5T|\theta_{A}^{(0)})}{P(5H5T|\theta_{A}^{(0)})+P(5H5T|\theta_{B}^{(0)})}\approx0.45</script>。</li><li>同理划分给B的比例是<script type="math/tex">1-z_1=\frac{P(5H5T|\theta_{B}^{(0)})}{P(5H5T|\theta_{A}^{(0)})+P(5H5T|\theta_{B}^{(0)})}\approx0.55</script>。</li></ul><p>对其他组也进行推算，得到$z_2\approx0.80$，$z_3\approx0.73$，$z_4\approx0.35$，$z_5\approx0.65$。</p><p><img src="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20从直观到数学理解/6.png" alt="不完全信息第三步"></p><p>（3）接下来得到了新的划分后的数据，可以更新参数了</p><ul><li>对于A来说，一共有21.3次向上8.6次向下，那么A硬币朝上的概率是$\hat \theta_{A}^{(1)}=\frac{21.3}{21.3+8.6}\approx0.71$。</li><li>对于B来说，一共有11.7次向上8.4次向下，那么B硬币朝上的概率是$\hat \theta_{B}^{(1)}=\frac{11.7}{11.7+8.4}\approx0.58$。</li></ul><p>（4）重复步骤（2）和（3），直到收敛，可以算得第十次循环之后<script type="math/tex">\hat \theta_{A}^{(10)}\approx0.80</script>，<script type="math/tex">\hat \theta_{B}^{(10)}\approx0.52</script>。</p><p>可以看到这个结果也跟之前完全信息算出来的比较接近。</p><p>&nbsp;<br>&nbsp;<br>&nbsp;</p><h1 id="0x30-EM算法的公式推导"><a href="#0x30-EM算法的公式推导" class="headerlink" title="0x30 EM算法的公式推导"></a>0x30 EM算法的公式推导</h1><h3 id="0x31-定义"><a href="#0x31-定义" class="headerlink" title="0x31 定义"></a>0x31 <strong>定义</strong></h3><ul><li>m个互相独立的样本组成的数据集$\mathbf{X}=(\mathbf{x}^{(1)},\mathbf{x}^{(2)},…\mathbf{x}^{(m)})$(这里每个$\mathbf{x}^{(k)}$对应硬币例子里面的一组共抛十次的数据，不知道每组属于哪种)</li><li>相对应的隐参数$\mathbf{z}=(z^{(1)},z^{(2)},…z^{(m)})$（每组数据属于哪种硬币的标记）</li><li>样本本身的模型参数$\mathbf{\theta}$（硬币例子就是<script type="math/tex">\mathbf{\theta}=(\theta_{A}, \theta_{B})</script>)</li></ul><p>对应似然函数为</p><ul><li>观察到$\mathbf{x}^{(k)}$的似然函数为$P(\mathbf{x}^{(k)}|\mathbf{\theta})$（例如硬币例子的$P(4H6T|\theta=0.3)$）</li><li>完全信息情况下的似然函数则是$P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})$（例如硬币例子的$P(4H6T,z=1|\theta_1=0.3,\theta_2=0.4)$。）<br>&nbsp;<br>&nbsp;<br>&nbsp;</li></ul><h3 id="0x32-最大似然估计"><a href="#0x32-最大似然估计" class="headerlink" title="0x32 最大似然估计"></a>0x32 <strong>最大似然估计</strong></h3><p>那么为了求模型参数$\mathbf{\theta}$，将$\mathbf{\theta}$看成是参数，求解让各个样本的似然函数的乘积$ L(\mathbf{\theta})$最大即可。</p><ul><li>也就是<script type="math/tex">\mathbf{\theta}=\mathop{\arg\max}_{\mathbf{\theta}} L(\mathbf{\theta})= \mathop{\arg\max}_{\mathbf{\theta}} \prod_{k=1}^{m}P(\mathbf{x}^{(k)}|\mathbf{\theta})= \mathop{\arg\max}_{\mathbf{\theta}} \sum_{k=1}^{m} \log P(\mathbf{x}^{(k)}|\mathbf{\theta})</script>，让<script type="math/tex">L(\mathbf{\theta})</script>对<script type="math/tex">\mathbf{\theta}</script>求导为零容易算出<script type="math/tex">\mathbf{\theta}</script></li><li>如果有隐函数的话则是<script type="math/tex">\mathbf{\theta},z=\mathop{\arg\max}_{\mathbf{\theta},z} L(\mathbf{\theta},z)=  \mathop{\arg\max}_{\mathbf{\theta},z} \sum_{k=1}^{m} \log \sum_{z} P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})</script>，由于包含了<script type="math/tex">\log \sum_{z}P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})</script>这个时候求导的计算量就很繁杂了</li></ul><p>解决思路是利用Jensen不等式$E[f(x)] \ge f(E(x))$,</p><p>将<script type="math/tex">\log \sum_{z}P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})</script>变成<script type="math/tex">\sum_{z} \log P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})</script>，即是下面的(1)到(2)，同时对P乘以了<script type="math/tex">\frac{q(z^{(k)})}{q(z^{(k)})}=1</script>。</p><p>因此，</p><script type="math/tex; mode=display">\begin{aligned} \sum_{k=1}^{m} \log \sum_{z} P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta}) & = \sum_{k=1}^{m} \log \sum_{z} q(z^{(k)}) \frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{q(z^{(k)})} \ \ \  (1) \\  & \ge \sum_{k=1}^{m} \sum_{z} q(z^{(k)}) \log  \frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{q(z^{(k)})}  \ \ (2) \\ & \to \sum_{k=1}^{m} \sum_{z} q(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta}^{old}) \log  \frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{q(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta}^{old})} \ \ (3)\\                              & = \sum_{k=1}^{m} \sum_{z} q(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta}^{old}) \log  P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta}) \\                     & \  \  \ - \sum_{k=1}^{m} \sum_{z} q(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta}^{old}) \log  q(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta}^{old})  \ \ (4)\\       & = Q(\mathbf{\theta},\mathbf{\theta}^{old})+constant \ \ (5) \end{aligned}</script><p>上面出来传说中的Q辅助函数，让Q最大化得出新的$\mathbf{\theta}$就是所谓的M步。从(2)到(3)步其实是E步。</p><p>所以EM算法就是上面推导公式的(3)(4)(5)之间不断循环直到收敛。</p><p>&nbsp;<br>&nbsp;</p><h3 id="0x33-意义解读"><a href="#0x33-意义解读" class="headerlink" title="0x33 意义解读"></a>0x33 意义解读</h3><p>&nbsp;</p><h6 id="E步来看"><a href="#E步来看" class="headerlink" title="E步来看,"></a>E步来看,</h6><p>（以下参考了<a href="https://zhuanlan.zhihu.com/p/36331115" target="_blank" rel="noopener">人人都懂EM算法</a>，略有修改）</p><p>(1)右边乘以了$ \frac{q(z^{(k)})}{q(z^{(k)})}=1$，而引进的未知分布q满足$ \sum_{z}  q(z^{(k)})=1$ </p><p>(2)里面的$ \sum_{z}  q(z^{(k)}) \log \frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{q(z^{(k)})}$其实是对$ \log \frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{q(z^{(k)})}$求加权平均，也就是求它的数学期望（Expectation）：$ E(\log \frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{q(z^{(k)})})$，这也是E步的名字来源。</p><p>为了让(2)能够取等号，也就是让$ L(\mathbf{\theta},z)$取一个下限，Jensen不等式告诉我们上面的数学期望里面的变量需要是一个常数，即$ \log \frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{q(z^{(k)})}=c$</p><p>去掉log之后有$P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})=cq(z^{(k)})$</p><p>累加后<script type="math/tex">\sum_{z}P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})=c\sum_{z}q(z^{(k)})=c</script></p><p>所以即$  q(z^{(k)})=\frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{c}=\frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{\sum_{z}P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}=\frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{P(\mathbf{x}^{(k)}|\mathbf{\theta})}=P(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta})$</p><p>q也就是已知$\mathbf{\theta}$和$\mathbf{x}^{(k)}$情况下求隐变量$\mathbf{z}^{(k)}$的分布，也就是隐变量的后验概率。然后我们才能继续算下面M步需要用到的$Q(\mathbf{\theta},\mathbf{\theta}^{old})$</p><p>$\mathbf{\theta}$不是未知数么？说得好，所以(3)里面代入了上次迭代算出的模型参数$\mathbf{\theta}^{old}$。</p><p>$Q(\mathbf{\theta},\mathbf{\theta}^{old})=E_{\mathbf{z}|\mathbf{X},\mathbf{\theta}^{old}}(\log L(\mathbf{X},\mathbf{Z}|\mathbf{\theta}))$</p><p>以上是E步。</p><p>&nbsp;</p><h6 id="M步来看，"><a href="#M步来看，" class="headerlink" title="M步来看，"></a>M步来看，</h6><p>最大化$Q(\mathbf{\theta},\mathbf{\theta}^{old})$更新$\mathbf{\theta}$。（(5)右边的constant可以忽略，不影响最大化似然函数的操作）</p><p>也就是<script type="math/tex">\mathbf{\theta}=\mathop{\arg\max}_{\mathbf{\theta}}Q(\mathbf{\theta},\mathbf{\theta}^{old})=\mathop{\arg\max}_{\mathbf{\theta}}\sum_{k=1}^{m} \sum_{z} q(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta}^{old}) \log  P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})</script></p><p>以上是M步。</p><p>&nbsp;</p><h6 id="另一个角度来看，"><a href="#另一个角度来看，" class="headerlink" title="另一个角度来看，"></a>另一个角度来看，</h6><script type="math/tex; mode=display">\begin{aligned} \sum_{k=1}^{m} \log  P(\mathbf{x}^{(k)}|\mathbf{\theta}) & =                         \sum_{k=1}^{m} \sum_{z} q(z^{(k)})\log  \frac{P(\mathbf{x}^{(k)}|\mathbf{\theta})P(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta})}{P(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta})} \ \ \  \ (6)\\                & = \sum_{k=1}^{m} \sum_{z} q(z^{(k)})\log \frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{P(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta})} \ \ \ \ \ \ \ \ \  (7) \\                                         & = \sum_{k=1}^{m}\sum_{z} q(z^{(k)}) \{\log \frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{q(z^{(k)})}- \log\frac{P(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta})}{q(z^{(k)})}\} \ \ \  (8) \\                                                               & = \sum_{k=1}^{m}\sum_{z} q(z^{(k)}) \log \frac{P(\mathbf{x}^{(k)},z^{(k)}|\mathbf{\theta})}{q(z^{(k)})}- \sum_{k=1}^{m}\sum_{z} q(z^{(k)}) \log \frac{P(z^{(k)}|\mathbf{x}^{(k)},\mathbf{\theta})}{q(z^{(k)})} \ \ \  (9) \\                                                            & = L(\mathbf{\theta},z)+KL[q(\mathbf{z})|| P(\mathbf{z}|\mathbf{x},\mathbf{\theta})] \ \ \ \ \ \ \ \ \ \ \ \ \ (10)\end{aligned}</script><p>(6)引入了隐函数后，(7)通过条件概率公式变换概率函数，然后就可以得到(10)。这里可以看出，我们是在构造一个隐函数的分布q。因为我们想让似然函数最大，那就是说(10)第二项的KL散度尽可能小，也就是要让构造出来的q尽可能和真实的隐函数分布接近，这时候$q(\mathbf{z})= P(\mathbf{z}|\mathbf{x},\mathbf{\theta})$，KL散度为零。</p><p><img src="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20从直观到数学理解/KL.png" alt="KL散度构造下限"></p><p>同时可以看出来刚才的(2)步的让Jensen不等式取等号的操作也是在让KL散度为零构造下限，也就是让$q(\mathbf{z})= P(\mathbf{z}|\mathbf{x},\mathbf{\theta})$取q分布的期望（Expectation）当做隐函数分布的估算。</p><p>然后利用q分布再对对数似然函数最大化（Maximization）更新$\theta$。</p><p><img src="https://hanspond.github.io/2018/09/02/EM%20Algorithm%20从直观到数学理解/kl.gif" alt="KL散度构造下限gif"></p><p>这个也是所谓的九层境界里面的第二层。（<a href="https://mp.weixin.qq.com/s/NbM4sY93kaG5qshzgZzZIQ" target="_blank" rel="noopener">EM算法的九层境界：Hinton和Jordan理解的EM算法</a>）</p><p>&nbsp;</p><h1 id="0x40-GMM混合高斯分布的例子"><a href="#0x40-GMM混合高斯分布的例子" class="headerlink" title="0x40 GMM混合高斯分布的例子"></a>0x40 GMM混合高斯分布的例子</h1><p>有空再更新</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>PRML</p></li><li><p><a href="https://www.zhihu.com/question/27976634" target="_blank" rel="noopener">知乎: 怎么通俗易懂地解释EM算法并且举个例子?</a>:彭一洋的回答有概括性的数学公式</p></li><li><p>Do, C. B., &amp; Batzoglou, S. (2008). What is the expectation maximization algorithm? Nature Biotechnology, 26(8), 897–899. <a href="https://doi.org/10.1038/nbt1406" target="_blank" rel="noopener">https://doi.org/10.1038/nbt1406</a></p></li><li><p><a href="https://ibug.doc.ic.ac.uk/media/uploads/documents/expectation_maximization-1.pdf" target="_blank" rel="noopener">https://ibug.doc.ic.ac.uk/media/uploads/documents/expectation_maximization-1.pdf</a></p></li><li><p><a href="https://www.jianshu.com/p/1121509ac1dc" target="_blank" rel="noopener">如何感性地理解EM算法？（抛硬币的详解）</a></p></li><li><p><a href="https://qiita.com/kenmatsu4/items/59ea3e5dfa3d4c161efb" target="_blank" rel="noopener">EMアルゴリズム徹底解説</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/NbM4sY93kaG5qshzgZzZIQ" target="_blank" rel="noopener">EM算法的九层境界：​Hinton和Jordan理解的EM算法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/NayLO3UMUXNcmDJlVx9ckg" target="_blank" rel="noopener">机器学习系列-强填EM算法在理论与工程之间的鸿沟（上）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/xrc12-ooUeAc02BVIZmnaA" target="_blank" rel="noopener">机器学习系列-强填EM算法在理论与工程之间的鸿沟（下）</a></p></li></ul><h1 id="վ-HᴗP-ի"><a href="#վ-HᴗP-ի" class="headerlink" title="վ HᴗP ի"></a>վ HᴗP ի</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]]}
});
&lt;/script&gt;

&lt;script type=&quot;te
      
    
    </summary>
    
      <category term="Machine Learning" scheme="https://hanspond.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Python" scheme="https://hanspond.github.io/tags/Python/"/>
    
      <category term="Programming" scheme="https://hanspond.github.io/tags/Programming/"/>
    
      <category term="Tech" scheme="https://hanspond.github.io/tags/Tech/"/>
    
      <category term="Algorithm" scheme="https://hanspond.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>MOCAP data extraction and visualization</title>
    <link href="https://hanspond.github.io/2018/08/10/MOCAP%20data%20extraction%20and%20visualization/"/>
    <id>https://hanspond.github.io/2018/08/10/MOCAP data extraction and visualization/</id>
    <published>2018-08-10T03:00:00.000Z</published>
    <updated>2018-08-06T12:51:00.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Motion-Capture-Technology"><a href="#Motion-Capture-Technology" class="headerlink" title="Motion Capture Technology"></a>Motion Capture Technology</h2><p>Short for MOCAP, this is used to record the movement of objects or, mainly people. The recorded data can be further utilized for other purpose in military, entertainment, sports, medical applications, also for creation and validation of computer vision and robotics.</p><h2 id="Overview-to-CMU-MOCAP-Database"><a href="#Overview-to-CMU-MOCAP-Database" class="headerlink" title="Overview to CMU MOCAP Database"></a>Overview to CMU MOCAP Database</h2><p><a href="http://mocap.cs.cmu.edu/" target="_blank" rel="noopener">http://mocap.cs.cmu.edu/</a></p><p>This is a famous motion dataset created by Carnegie Mellon University Graphics Lab.</p><p>It contains 2605 trials of motions in 6 categories and 23 subcategories by 111 human subjects. Humans wear a suit with 41 markers which can be captured with 12 Vicon infrared MX-40 cameras, each of which is capable of recording 120 Hz with images of 4 megapixel resolution.</p><p>The 3D data is provided in two way:</p><ul><li>Marker position, in .c3d files format.</li><li>Skeleton movement, in a .vsk<em>.v pair or .asf</em>.amc pair, a .bvh format is also created and provided by other researchers.</li></ul><p>Here we use the original .asf/.amc pair to extract the 3D data and to visualize.</p><h2 id="asf-amc-file-format"><a href="#asf-amc-file-format" class="headerlink" title=".asf/.amc file format"></a>.asf/.amc file format</h2><p>.asf/.amc was created by a game company Acclaim which no longer exist.</p><h3 id="asf-for-skeleton"><a href="#asf-for-skeleton" class="headerlink" title=".asf for skeleton"></a>.asf for skeleton</h3><p>an example of asf file from 01 subject:</p><pre><code># AST/ASF file generated using VICON BodyLanguage# -----------------------------------------------:version 1.10   // Version of the skeleton definition :name VICON     // Arbitrary name for the skeleton:units          // Units definition  mass 1.0  length 0.45   // In this CMU dataset, all the data are multiplied by 0.45 in *INCHES*  angle deg     // Euler angles are in degrees:documentation  // Arbitrary documentation   .ast/.asf automatically generated from VICON data using   VICON BodyBuilder and BodyLanguage model FoxedUp or BRILLIANT.MOD:root                        // This is the root of the skeleton   order TX TY TZ RX RY RZ   // The order of appearence of 6 degrees of freedom in AMC file   axis XYZ                  // Rotation order or the root   position 0 0 0            // Initial position/offset in World Coodinate System   orientation 0 0 0         // Initial orientation in WCS:bonedata                    // Here starts the definition of each bone segment  begin     id 1            // Unique id for each bone        name lhipjoint  // Unique name for each bone      direction 0.566809 -0.746272 0.349008       // Vector describing direction of the bone segment from      // parent to child in world coordinate system     length 2.40479   // Length of the bone segment     // The above direction and length of a segment determine      //the offset of the child from the parent     axis 0 0 0  XYZ  // Rotation of local coordinate system for                       //this bone relative to the world coordinate                       //system. In .amc file the rotation angles                       //for this bone for each time frame will be                       //defined relative to this local coordinate                       //system   end  begin     id 2      name lfemur     direction 0.34202 -0.939693 0       length 7.1578       axis 0 0 20  XYZ    dof rx ry rz            // Not always 3 degrees of freedom    limits (-160.0 20.0)    // Limits of each rotation           (-70.0 70.0)           (-60.0 70.0)  end  ...  ...  ...  :hierarchy                  // This part defines the hierarchy of each bone  // e.g. root is the parent to lhipjoint, rhipjoint and lowerback  begin    root lhipjoint rhipjoint lowerback    lhipjoint lfemur    lfemur ltibia    ltibia lfoot    lfoot ltoes    rhipjoint rfemur    rfemur rtibia    rtibia rfoot    rfoot rtoes    lowerback upperback    upperback thorax    thorax lowerneck lclavicle rclavicle    lowerneck upperneck    upperneck head    lclavicle lhumerus    lhumerus lradius    lradius lwrist    lwrist lhand lthumb    lhand lfingers    rclavicle rhumerus    rhumerus rradius    rradius rwrist    rwrist rhand rthumb    rhand rfingers  end</code></pre><p>Fig 1: Definition of the skeleton</p><p><img src="http://graphics.cs.cmu.edu/nsp/course/15-464/Fall05/assignments/image006.gif" alt="Fig 1"></p><p>Some notes:</p><ul><li>The WCS is originally Y up.</li><li>Euler angles are used</li><li>In the ASF file the order is given left to right so that an order of “XYZ” is: vM = vXYZ</li><li>.amc file records the axis data of each bone frame by frame</li></ul><h3 id="amc-for-motion"><a href="#amc-for-motion" class="headerlink" title=".amc for motion"></a>.amc for motion</h3><pre><code class="lang-python">#!OML:ASF H:\Terrain\Patient Classification 1\PLAYGROUND\JustinFriday\JustinFriday.ASF:FULLY-SPECIFIED:DEGREES1   // Frame numbersroot 9.37216 17.8693 -17.3198 -2.01677 -7.59696 -3.23164lowerback 2.30193 -0.395121 1.17299upperback 0.0030495 -0.462657 2.70388thorax -1.27453 -0.231833 2.13151lowerneck -9.32819 -3.76531 -6.70788upperneck 27.8377 -3.2335 -3.01318head 10.556 -2.55728 -0.318388rclavicle 3.64024e-015 -6.75868e-015rhumerus -29.5133 -11.7797 -80.4307rradius 21.1829rwrist -7.55893rhand -17.4806 -21.0413rfingers 7.12502rthumb 8.77158 -50.8391lclavicle 3.64024e-015 -6.75868e-015lhumerus 17.2039 -14.515 62.7889lradius 136.231lwrist 10.1195lhand -37.631 -17.4438lfingers 7.12502lthumb -10.6834 12.2646rfemur -0.629535 4.65229 22.5467rtibia 26.4457rfoot -15.2124 -9.97437rtoes 3.93605lfemur 4.00236 1.20472 -13.8412ltibia 20.088lfoot -16.1868 6.57726ltoes -4.617892root 9.37285 17.8666 -17.3192 -2.06376 -7.58832 -3.1009lowerback 2.29991 -0.349181 1.09181.........</code></pre><h3 id="Interpretation"><a href="#Interpretation" class="headerlink" title="Interpretation"></a>Interpretation</h3><p>As shown by the data hierarchy, human motions are represented as the translation offset of the root, and the rotation offsets of its child bones. </p><p>To get WCS of a specific bone segment, we must calculate the WCS of its parent, recursively to the root.</p><p>L = CinvMCB</p><h3 id="Other-useful-references"><a href="#Other-useful-references" class="headerlink" title="Other useful references"></a>Other useful references</h3><p><a href="http://research.cs.wisc.edu/graphics/Courses/cs-838-1999/Jeff/ASF-AMC.html" target="_blank" rel="noopener">http://research.cs.wisc.edu/graphics/Courses/cs-838-1999/Jeff/ASF-AMC.html</a><br><a href="http://graphics.cs.cmu.edu/nsp/course/15-464/Fall05/assignments/StartupCodeDescription.html" target="_blank" rel="noopener">http://graphics.cs.cmu.edu/nsp/course/15-464/Fall05/assignments/StartupCodeDescription.html</a><br><a href="http://web.cse.ohio-state.edu/~parent.1/classes/888/Mocap/index.html" target="_blank" rel="noopener">http://web.cse.ohio-state.edu/~parent.1/classes/888/Mocap/index.html</a><br><a href="http://www.darwin3d.com/gamedev/articles/col0198.pdf" target="_blank" rel="noopener">http://www.darwin3d.com/gamedev/articles/col0198.pdf</a><br><a href="http://mukai-lab.org/content/MotionCaptureDataFile.pdf" target="_blank" rel="noopener">http://mukai-lab.org/content/MotionCaptureDataFile.pdf</a><br><a href="https://blog.csdn.net/zb1165048017/article/details/49358089" target="_blank" rel="noopener">https://blog.csdn.net/zb1165048017/article/details/49358089</a><br><a href="https://blog.csdn.net/zb1165048017/article/details/49339493" target="_blank" rel="noopener">https://blog.csdn.net/zb1165048017/article/details/49339493</a><br><a href="http://studentnet.cs.manchester.ac.uk/resources/library/3rd-year-projects/2016/jiayun.wang.pdf" target="_blank" rel="noopener">http://studentnet.cs.manchester.ac.uk/resources/library/3rd-year-projects/2016/jiayun.wang.pdf</a></p><h2 id="MOCAP-TOOLBOX"><a href="#MOCAP-TOOLBOX" class="headerlink" title="MOCAP TOOLBOX"></a>MOCAP TOOLBOX</h2><p>There are several existing projects available in Github for processing and visualization of the CMU MOCAP .asf/.amc file.</p><p>Here is one used by most researchers:<br><a href="https://github.com/lawrennd/mocap" target="_blank" rel="noopener">https://github.com/lawrennd/mocap</a></p><pre><code class="lang-matlab">&gt;&gt; % Read .asf skeleton file&gt;&gt; skel_86 = acclaimReadSkel(&#39;examples/86.asf&#39;);&gt;&gt; % Read .amc channels file&gt;&gt; [channels_86_10, skel_86] = acclaimLoadChannels(&#39;examples/86_10.amc&#39;, skel);&gt;&gt; % Visualize the skeleton in motion&gt;&gt; skelPlayData(skel_86, channels_86_10, 1/120);</code></pre><p>Be aware that this matlab code was written more than a decade ago and it uses an obselete function of <strong>getline</strong> which will cause problems if run in a newer version of matlab. The solution is to switch to another function of <strong>fgetl</strong>.</p><p>Modified version: <a href="https://github.com/hanspond/mocap" target="_blank" rel="noopener">https://github.com/hanspond/mocap</a></p><p>Visualization of subject 02 motion 02<br><img src="MOCAP%20data%20extraction%20and%20visualization/skel.gif" alt=""></p><p>Visualization of subject 02 motion 02 with a ellipsoidal model</p><p><img src="MOCAP%20data%20extraction%20and%20visualization/ellipsoid.gif" alt=""></p><p>Others tool:</p><p><a href="https://github.com/CalciferZh/AMCParser" target="_blank" rel="noopener">https://github.com/CalciferZh/AMCParser</a><br><a href="https://github.com/CalciferZh/SMPL" target="_blank" rel="noopener">https://github.com/CalciferZh/SMPL</a><br><a href="https://github.com/surenkum/c3d_to_xyz" target="_blank" rel="noopener">https://github.com/surenkum/c3d_to_xyz</a><br><a href="https://github.com/CalciferZh/CMU-MoCap-Washer" target="_blank" rel="noopener">https://github.com/CalciferZh/CMU-MoCap-Washer</a></p><p>A list to other MOCAP databases:<br><a href="http://www.jeroenvanboxtel.com/MocapDatabases.html" target="_blank" rel="noopener">http://www.jeroenvanboxtel.com/MocapDatabases.html</a></p><h1 id="վ-HᴗP-ի"><a href="#վ-HᴗP-ի" class="headerlink" title="վ HᴗP ի"></a>վ HᴗP ի</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Motion-Capture-Technology&quot;&gt;&lt;a href=&quot;#Motion-Capture-Technology&quot; class=&quot;headerlink&quot; title=&quot;Motion Capture Technology&quot;&gt;&lt;/a&gt;Motion Capt
      
    
    </summary>
    
      <category term="Computer Vision" scheme="https://hanspond.github.io/categories/Computer-Vision/"/>
    
    
      <category term="Programming" scheme="https://hanspond.github.io/tags/Programming/"/>
    
      <category term="tech" scheme="https://hanspond.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>直观图解OFDM原理</title>
    <link href="https://hanspond.github.io/2018/06/09/%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/"/>
    <id>https://hanspond.github.io/2018/06/09/直观图解OFDM原理/</id>
    <published>2018-06-09T03:00:00.000Z</published>
    <updated>2018-08-19T05:28:25.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>人生如幻，不知怎么的碰（bei）巧（ju）和OFDM对上了。<br>这是一个大坑，很大又绕不过去的坑，不是三言两语能够解释清楚的，目测需要融合贯通理解数学的三角函数，傅里叶，通原的检波，调制，信道特征，信号处理的采样，电子元件特征等等知识才能有个大概了解。详细可以参考专（da）业（bu）书（tou）：L. Hanzo et al., OFDM and MC-CDMA for Broadband Multi-User Communications, Wiley, 2003.</p><p>时间精力有限，先来个直观图解，也好方便以后深入。<br>下文主要参考另一篇很好的入门文章作3D图：<a href="https://blog.csdn.net/madongchunqiu/article/details/18614233" target="_blank" rel="noopener">给”小白”图示讲解OFDM的原理 - CSDN博客</a></p><h2 id="正交检波-Orthogonality"><a href="#正交检波-Orthogonality" class="headerlink" title="正交检波 Orthogonality"></a>正交检波 Orthogonality</h2><p>不同的正弦倍谐波是正交的。意思是不同频率倍数的正弦波积分之后为零。</p><p><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/har1%203.png" alt=""><br><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/har2%203.png" alt=""><br><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/har3%203.png" alt=""></p><p><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/har4%203.png" alt=""></p><p>如前面三图所示只有频率相同的时候，积分器的结果不为零。频率不同的时候积分在x轴上下面积相同，积分结果是零。<br>另外，sin和cos（也就是90度相位差）的两个信号的积分结果一样是零，所以sin和cos也是正交的。</p><h2 id="谐波的频分复用-Frequency-Division-Multiplexing"><a href="#谐波的频分复用-Frequency-Division-Multiplexing" class="headerlink" title="谐波的频分复用 Frequency Division Multiplexing"></a>谐波的频分复用 Frequency Division Multiplexing</h2><p>了解不同频率的正弦余弦的正交性这一点之后，我们就可以同时利用这个特征同时发送不同频率的正弦余弦波。而在接收器一侧，使用不同频率积分器积分之后，我们是有能力分辨出不同频率谐波。<br><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/harmonics%203.png" alt=""></p><p>上图中，1sin1t+0sin2t+2sin3t+0sin4t+1sin5t的信号（10201）同时发送。接收器里面，sin2t和sin4t的积分器输出为零，而sin1t和sin3t的积分器输出不为零，而且sin3t的信号功率大。接收器检测到了（1020），sin5t的信号1检测不到。</p><h2 id="时域和频域"><a href="#时域和频域" class="headerlink" title="时域和频域"></a>时域和频域</h2><p>频域和时域其实画成3D就很好理解了</p><p><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/all_cos%203.gif" alt=""></p><p>上图展示了四个余弦波（也叫In phase）谐波，每个波的频谱都是1，所以可以看成是信息（1,1,1,1）。每个波的振幅取值范围是0或者1的话，这四个波就可以传递4bit的信息。也就是每个谐波都是一个ASK。</p><p><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/cos_coded_1%203.gif" alt=""><br><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/cos_coded_2%203.gif" alt=""><br><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/cos_coded_3%203.gif" alt=""></p><p>除了振幅，也可以改变相位用来传输数据。这个时候相当于APSK吧。<br>换个角度看频域和时域是不是清楚了？</p><p><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/cos_sin%203.gif" alt=""></p><p>别忘了还可以加入正交的正弦波（也叫Quadrature），四个余弦波（I）和四个正弦波（Q）都可以有不同的频谱，上图的信息是（11,01,10,00）。这不就是QAM了吗？</p><p><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/complex%203.gif" alt=""></p><p>别忘了，其实我们可以用一个复数信号来代替同频率的一个正弦波和一个余弦波的和。也就是欧拉公式丢掉右边部分的i。通信老师会给你说这都是为了方便，用一个复数代替两个三角函数就可以将很多运算公式简约很多了。<br><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/texclip20180609140610%202.png" alt=""></p><p>传递的信息变成了（A1,A2,A3,A4），这里面的每一个symbol的Ak都是复数。</p><p>然后仔细一看在时域的复信号的求和公式<br><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/texclip20180609140523%202.png" alt=""></p><p>这不就是一个傅里叶级数么！（该复习的复习去）<br>然后离散的傅里叶级数不是可以用IDFT/IFFT来计算么！</p><p>由此我们就可以用对复数symbol的数列进行IDFT直接得到时域的发送信号了。</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/architecture%203.png" alt=""></p><p>动图都了解之后，系统架构就很直白了。<br>以传输11011000为例，首先分成11,01,10,00并列的四个symbol，然后加入pilot（以后有空再谈），对四个复数symbol进行IDFT_IFFT就可以得到时域的实际发送的信号，然后再加入CP_GI，最后转换成数字数据，升到中频/高频后发送。接收器是倒过来的操作。</p><h2 id="采样方面来看"><a href="#采样方面来看" class="headerlink" title="采样方面来看"></a>采样方面来看</h2><p><img src="%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3OFDM%E5%8E%9F%E7%90%86/pulse_sampling%203.gif" alt=""></p><p>采样方面，采样间隔决定了频域上面sinc函数的零点之间间隔。</p><p>看上图第一个和第四个子载波，改变采样频率的话，第一个子载波的频域sinc函数会和其他子载波重叠，改变子载波频率距离的话，第四个子载波的采样数据也会和其他子载波重叠。</p><p>所以，采样间隔和子载波频率间隔两者必须要符合一定规则。这样采样后的频域数据sinc函数的零点会刚好和其他子载波的，频率以及零点重合，也就是说只有这样子载波之间才能不影响，保持正交。</p><h2 id="其他特征"><a href="#其他特征" class="headerlink" title="其他特征"></a>其他特征</h2><h3 id="PAPR"><a href="#PAPR" class="headerlink" title="PAPR"></a>PAPR</h3><p>这个看上面的gif就可以很好理解了。<br>PAPR是合成后的发送信号的峰值和平均值的比。<br>传输信息的时候，每个子载波的频幅和相位可以假设为独立随机事件。所有子载波频幅和相位出现一致的情况下（所有子载波的symbol一样），叠加而成的合成波会出现非常大的峰值，可以超出平均值很多dB，总体来说子载波越多，PAPR越大。<br>而电子元件的放大器的线性响应范围是有限的，也就是说我们的symbol组合要求一个超出线性范围的峰值的时候，放大器实际上是做不到的。</p><h3 id="GI-amp-CP"><a href="#GI-amp-CP" class="headerlink" title="GI &amp; CP"></a>GI &amp; CP</h3><p>待续</p><h3 id="CFO-amp-SFO"><a href="#CFO-amp-SFO" class="headerlink" title="CFO &amp; SFO"></a>CFO &amp; SFO</h3><h2 id="动图代码"><a href="#动图代码" class="headerlink" title="动图代码"></a>动图代码</h2><p><a href="https://github.com/hanspond/visual_comm" target="_blank" rel="noopener">https://github.com/hanspond/visual_comm</a></p><p>可以手动调整信号，直观观察OFDM信号变化<br><img src="https://github.com/hanspond/visual_comm/raw/master/example/ofdm_complex-optimize.gif" alt="OFDM_1"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/madongchunqiu/article/details/18614233" target="_blank" rel="noopener">给”小白”图示讲解OFDM的原理 - CSDN博客</a><br><a href="https://zhuanlan.zhihu.com/p/26868447" target="_blank" rel="noopener">正交频分复用（OFDM）原理</a><br>L. Hanzo et al., OFDM and MC-CDMA for Broadband Multi-User Communications, Wiley, 2003.<br>Weinstein, S. B. (2009). The history of orthogonal frequency-division multiplexing. <em>IEEE Communications Magazine</em>, <em>47</em>(11), 26–35. https: doi. org_10. 1109_MCOM. 2009. 5307460</p><h1 id="վ-HᴗP-ի"><a href="#վ-HᴗP-ի" class="headerlink" title="վ HᴗP ի"></a>վ HᴗP ի</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;人生如幻，不知怎么的碰（bei）巧（ju）和OFDM对上了。&lt;br&gt;这是一个大坑，很大又绕不过去的坑，不是三言两语能够解释清楚的，目测需要融
      
    
    </summary>
    
      <category term="Wireless Communication" scheme="https://hanspond.github.io/categories/Wireless-Communication/"/>
    
    
      <category term="Python" scheme="https://hanspond.github.io/tags/Python/"/>
    
      <category term="Programming" scheme="https://hanspond.github.io/tags/Programming/"/>
    
      <category term="tech" scheme="https://hanspond.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>基于nRF52832 SoC的RedBear BLE Nano v2物联网开发板初体验</title>
    <link href="https://hanspond.github.io/2018/03/04/%E5%9F%BA%E4%BA%8EnRF52832%20SoC%E7%9A%84RedBear%20BLE%20NANO%20Kit%20v2%E7%89%A9%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://hanspond.github.io/2018/03/04/基于nRF52832 SoC的RedBear BLE NANO Kit v2物联网开发板初体验/</id>
    <published>2018-03-04T10:00:00.000Z</published>
    <updated>2018-03-05T13:47:43.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IoT大杀器nRF52832"><a href="#IoT大杀器nRF52832" class="headerlink" title="IoT大杀器nRF52832"></a>IoT大杀器nRF52832</h2><p><img src="%E5%9F%BA%E4%BA%8EnRF52832%20SoC%E7%9A%84RedBear%20BLE%20NANO%20Kit%20v2%E7%89%A9%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%9D%E4%BD%93%E9%AA%8C/nRF52832.png" alt=""></p><p>nRF52832 SoC芯片主要参数：</p><ul><li>ARM Cortex-M4，32-bit </li><li>最大主频64 MHz </li><li>内部闪存512kB</li><li>SRAM达到64kB</li><li>支持Bluetooth 5和NFC</li><li>支持多种开发环境</li></ul><p>相比之下Arduino Uno的ATmega328芯片的主频才16MHz，Flash 32kB，SRAM 2kB，不带任何无线功能。对比强烈。</p><p>Nordic的官方组件评测可以看：<br><a href="http://www.sohu.com/a/127214173_464086" target="_blank" rel="noopener">一款基于Cortex-M4的BLE SoC——Nordic nRF52开发套件评测<em>搜狐科技</em>搜狐网</a><br>Arduino也推出了Primo这个板子：<br><a href="http://www.eefocus.com/communication/m/362500" target="_blank" rel="noopener">Arduino使用Nordic nRF52832 SoC的Arduino Primo基板-通信/网络-与非网</a></p><h2 id="RedBear-BLE-Nano-Kit-v2"><a href="#RedBear-BLE-Nano-Kit-v2" class="headerlink" title="RedBear BLE Nano Kit v2"></a>RedBear BLE Nano Kit v2</h2><p>入手的是RedBear推出的超小型开发板。小巧全能就是王道！<br>这个板子虽然是某香港/深圳公司做的，中文世界的介绍几乎没有，RedBear的人看到此文不介意给本人支付广告费(@HᴗP@)。<br><img src="%E5%9F%BA%E4%BA%8EnRF52832%20SoC%E7%9A%84RedBear%20BLE%20NANO%20Kit%20v2%E7%89%A9%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%9D%E4%BD%93%E9%AA%8C/Nano2.png" alt=""></p><p>nRF52832的特性之外，还有：</p><ul><li>Arduino IDE，Mbed，JavaScript，Nordic nRF52 SDK，Python，Apache Mynewt，FreeRTOS等开发环境</li><li>板载LED D13</li><li>UART，SPI，I2C</li><li>最大11个端口，也足够用了</li><li>VDD除了3.3V，还支持1.8V的输出</li><li>可以在1.8V-3.6V工作</li><li>大小只有大概2厘米见方</li><li>支持Over-The-Air，也就是不连电脑直接通过BLE写程序</li></ul><p><img src="%E5%9F%BA%E4%BA%8EnRF52832%20SoC%E7%9A%84RedBear%20BLE%20NANO%20Kit%20v2%E7%89%A9%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%9D%E4%BD%93%E9%AA%8C/Nano2_Pinout.png" alt=""></p><p>还有官方Kit，多了USB读写器DAPLink<br><img src="%E5%9F%BA%E4%BA%8EnRF52832%20SoC%E7%9A%84RedBear%20BLE%20NANO%20Kit%20v2%E7%89%A9%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%9D%E4%BD%93%E9%AA%8C/DAPLink_Pinout.jpg" alt=""></p><p>开发板介绍：<br><a href="https://www.kickstarter.com/projects/redbearinc/bluetooth-5-ready-ble-module-nano-2-and-blend-2/" target="_blank" rel="noopener">Kickstarter page</a><br><a href="https://github.com/redbear/nRF5x/tree/master/nRF52832" target="_blank" rel="noopener">nRF5x/nRF52832 at master · redbear/nRF5x · GitHub</a><br><a href="http://redbearlab.com" target="_blank" rel="noopener">RedBear</a> （注意：官网是找不到Nano2介绍页面的=͟͟͞͞(HㅍP)，只有<br>基于nRF51832的一代Nano的介绍，两代非常不同 ）</p><p>官方还有扩展板</p><h2 id="RedBear-BLE-Nano-Kit-v2开箱"><a href="#RedBear-BLE-Nano-Kit-v2开箱" class="headerlink" title="RedBear BLE Nano Kit v2开箱"></a>RedBear BLE Nano Kit v2开箱</h2><p><img src="%E5%9F%BA%E4%BA%8EnRF52832%20SoC%E7%9A%84RedBear%20BLE%20NANO%20Kit%20v2%E7%89%A9%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%9D%E4%BD%93%E9%AA%8C/IMG_0215.jpg" alt=""></p><p>可以看到其实BLE Nano的板子只比USB插口大了一点点，大概就是正常人的拇指那么大吧。下面作对比的是ESP32。</p><p>插电前必须注意插入读写器的方向，白色的小熊logo是朝外的。</p><p>插电后就可以进行BLE测试，本来已经预先安装了心率服务：<a href="https://github.com/redbear/nRF5x/blob/master/nRF52832/docs/Getting_Started_Guide.md" target="_blank" rel="noopener">nRF5x/Getting_Started_Guide.md at master · redbear/nRF5x · GitHub</a></p><p>windows系统可能需要先安装mbed的驱动：<a href="https://developer.mbed.org/handbook/Windows-serial-configuration" target="_blank" rel="noopener">https://developer.mbed.org/handbook/Windows-serial-configuration</a></p><h2 id="Arduino-IDE追加库"><a href="#Arduino-IDE追加库" class="headerlink" title="Arduino IDE追加库"></a>Arduino IDE追加库</h2><p>按照官方介绍操作：<a href="https://github.com/redbear/nRF5x/blob/master/nRF52832/docs/Arduino_Board_Package_Installation_Guide.md" target="_blank" rel="noopener">nRF5x/Arduino_Board_Package_Installation_Guide.md at master · redbear/nRF5x · GitHub</a></p><ul><li>先在设置那里添加链接：<a href="https://redbear.github.io/arduino/package_redbear_nRF5x_index.json" target="_blank" rel="noopener">https://redbear.github.io/arduino/package_redbear_nRF5x_index.json</a></li><li>然后在Boards Manager里面搜索RedBear nRF52832</li></ul><p>安装完了之后就可以看到IDE里面出现了BLE_Nano2的板子，注意不要搞混一代Nano和二代了，两者不通用。</p><p>这时候可以进行Arduino标准的LED测试，记得端口换成D13就行。</p><h2 id="BLE-Simple-Chat测试"><a href="#BLE-Simple-Chat测试" class="headerlink" title="BLE Simple Chat测试"></a>BLE Simple Chat测试</h2><p>先安装官方的APP：BLEController<br>Arduino IDE里面打开File&gt;Examples&gt;BLE_Examples&gt;SimpleChat并上传</p><p>官方APP里面找到设备并连接，<br>在手机里面输入文字，Serial Monitor里面就有反应。</p><p><img src="%E5%9F%BA%E4%BA%8EnRF52832%20SoC%E7%9A%84RedBear%20BLE%20NANO%20Kit%20v2%E7%89%A9%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%9D%E4%BD%93%E9%AA%8C/merge_from_ofoct.jpg" alt=""></p><p>反过来Serial Monitor里面输入文字，手机就有输出。<br>实现简单的文字传输功能。</p><p><img src="%E5%9F%BA%E4%BA%8EnRF52832%20SoC%E7%9A%84RedBear%20BLE%20NANO%20Kit%20v2%E7%89%A9%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%9D%E4%BD%93%E9%AA%8C/Capture.PNG" alt=""></p><h2 id="并非Arduino风格的BLE语法"><a href="#并非Arduino风格的BLE语法" class="headerlink" title="并非Arduino风格的BLE语法"></a>并非Arduino风格的BLE语法</h2><p>好了，用是可以使用，看一下具体代码的话就会发现，BLE部分的语法并不是一般arduino里面常用的那种，而是类似mbed的语法，这个说明又是一个大坑了。<br>另外可以用Nordic SDK，自由度更高，开发HID等高级功能逃不过，当然这个坑更大更深。</p><pre><code class="lang-c++">/* * Copyright (c) 2016 RedBear * * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */#include &lt;nRF5x_BLE_API.h&gt;#define DEVICE_NAME            &quot;BLE_Peripheral&quot;   // 被搜索的时候看到的名字#define TXRX_BUF_LEN           20      // 这个是BLE每次传输缓冲的最大字节数，最大20BLE                            ble;Timeout                        timeout;static uint8_t rx_buf[TXRX_BUF_LEN];  // 这个是BLE每次传输缓冲的最大字节数，最大20static uint8_t rx_buf_num;static uint8_t rx_state=0;// 需要自己定义16进制的uuid// The uuid of service and characteristicsstatic const uint8_t service1_uuid[]        = {0x71, 0x3D, 0, 0, 0x50, 0x3E, 0x4C, 0x75, 0xBA, 0x94, 0x31, 0x48, 0xF1, 0x8D, 0x94, 0x1E};static const uint8_t service1_tx_uuid[]     = {0x71, 0x3D, 0, 3, 0x50, 0x3E, 0x4C, 0x75, 0xBA, 0x94, 0x31, 0x48, 0xF1, 0x8D, 0x94, 0x1E};static const uint8_t service1_rx_uuid[]     = {0x71, 0x3D, 0, 2, 0x50, 0x3E, 0x4C, 0x75, 0xBA, 0x94, 0x31, 0x48, 0xF1, 0x8D, 0x94, 0x1E};static const uint8_t uart_base_uuid_rev[]   = {0x1E, 0x94, 0x8D, 0xF1, 0x48, 0x31, 0x94, 0xBA, 0x75, 0x4C, 0x3E, 0x50, 0, 0, 0x3D, 0x71};uint8_t tx_value[TXRX_BUF_LEN] = {0,};uint8_t rx_value[TXRX_BUF_LEN] = {0,};// Initialize value of charsGattCharacteristic  characteristic1(service1_tx_uuid, tx_value, 1, TXRX_BUF_LEN, GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_WRITE | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_WRITE_WITHOUT_RESPONSE );      // 定义特征的读写权限等GattCharacteristic  characteristic2(service1_rx_uuid, rx_value, 1, TXRX_BUF_LEN, GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY);GattCharacteristic *uartChars[] = {&amp;characteristic1, &amp;characteristic2};GattService         uartService(service1_uuid, uartChars, sizeof(uartChars) / sizeof(GattCharacteristic *));// BLE断开后的操作void disconnectionCallBack(const Gap::DisconnectionCallbackParams_t *params) {  Serial.println(&quot;Disconnected!&quot;);  Serial.println(&quot;Restarting the advertising process&quot;);  ble.startAdvertising();  // 开始advertising}// central设备有write请求时候的操作void gattServerWriteCallBack(const GattWriteCallbackParams *Handler) {  uint8_t buf[TXRX_BUF_LEN];  uint8_t index;  uint16_t bytesRead = TXRX_BUF_LEN;  Serial.println(&quot;onDataWritten : &quot;);  if (Handler-&gt;handle == characteristic1.getValueAttribute().getHandle()) {    // 读出特征的数据ble.readCharacteristicValue(characteristic1.getValueAttribute().getHandle(), buf, &amp;bytesRead);    Serial.print(&quot;bytesRead: &quot;);    Serial.println(bytesRead, HEX);    for(index=0; index&lt;bytesRead; index++) {      Serial.write(buf[index]);    }    Serial.println(&quot;&quot;);  }}void m_uart_rx_handle() {   //update characteristic data  ble.updateCharacteristicValue(characteristic2.getValueAttribute().getHandle(), rx_buf, rx_buf_num);  memset(rx_buf, 0x00,20);  rx_state = 0;}void uart_handle(uint32_t id, SerialIrq event) {   /* Serial rx IRQ */  if(event == RxIrq) {    if(rx_state == 0) {      rx_state = 1;      timeout.attach_us(m_uart_rx_handle, 100000);      rx_buf_num=0;    }    while(Serial.available()) {      if(rx_buf_num &lt; 20) {        rx_buf[rx_buf_num] = Serial.read();        rx_buf_num++;      }      else {        Serial.read();      }    }  }}void setup() {  // put your setup code here, to run once  Serial.begin(9600);  Serial.attach(uart_handle);  ble.init();  ble.onDisconnection(disconnectionCallBack);  ble.onDataWritten(gattServerWriteCallBack);  // setup adv_data and srp_data  ble.accumulateAdvertisingPayload(GapAdvertisingData::BREDR_NOT_SUPPORTED);  ble.accumulateAdvertisingPayload(GapAdvertisingData::SHORTENED_LOCAL_NAME,                                   (const uint8_t *)&quot;TXRX&quot;, sizeof(&quot;TXRX&quot;) - 1);  ble.accumulateAdvertisingPayload(GapAdvertisingData::COMPLETE_LIST_128BIT_SERVICE_IDS,                                   (const uint8_t *)uart_base_uuid_rev, sizeof(uart_base_uuid_rev));  // set adv_type  ble.setAdvertisingType(GapAdvertisingParams::ADV_CONNECTABLE_UNDIRECTED);  // add service  ble.addService(uartService);  // set device name  ble.setDeviceName((const uint8_t *)&quot;Simple Chat&quot;);  // set tx power,valid values are -40, -20, -16, -12, -8, -4, 0, 4  ble.setTxPower(4);  // set adv_interval, 100ms in multiples of 0.625ms.  ble.setAdvertisingInterval(160);  // set adv_timeout, in seconds  ble.setAdvertisingTimeout(0);  // start advertising  ble.startAdvertising();  Serial.println(&quot;Advertising Start!&quot;);}void loop() {    ble.waitForEvent();}</code></pre><h2 id="诸多参考"><a href="#诸多参考" class="headerlink" title="诸多参考"></a>诸多参考</h2><p><a href="http://blog.hisurga.com/entry/2017/04/12/070000" target="_blank" rel="noopener">BLE Nanoを試してみました - surga Lab</a><br><a href="http://homemadegarbage.0t0.jp/blenano-1" target="_blank" rel="noopener">RedBearLab BLE Nano の設定方法とOTA | Home Made Garbage</a><br><a href="http://homemadegarbage.0t0.jp/ble_car01" target="_blank" rel="noopener">BLE Car01</a><br><a href="https://robopara.co.jp/blenanov2をarduinoideを使ってプログラミングする方法/" target="_blank" rel="noopener">blenanov2をarduinoideを使ってプログラミングする方法</a><br><a href="http://nn-hokuson.hatenablog.com/entry/2018/01/11/195229" target="_blank" rel="noopener">【Arduino】BLE NanoでスマートフォンとBLE通信する - おもちゃラボ</a><br><a href="http://blog.livedoor.jp/sce_info3-craft/archives/9443137.html" target="_blank" rel="noopener">ArduinoRedBearLab BLE Nanoを使ってみる : 工作と競馬</a><br><a href="http://jellyware.jp/kurage/blenano/blenano_minibread.html" target="_blank" rel="noopener">BLE NanoではじめてのBLE通信！クラゲのIoTテクノロジー</a><br><a href="http://jellyware.jp/kurage/blenano/blenano2_minibread.html" target="_blank" rel="noopener">BLE Nano2ではじめてのBLE通信！クラゲのIoTテクノロジー</a><br><a href="http://asukiaaa.blogspot.jp/2017/05/blenanolcd.html" target="_blank" rel="noopener">BLEnanoで必要なときだけLCDに情報を表示する方法 : 試行錯誤な日々</a></p><p>有事别忘了骚扰官方论坛：<a href="http://discuss.redbear.cc/c/nrf5x/ble-nano-2-cortex-m4f" target="_blank" rel="noopener">BLE Nano 2 (nRF52832) - Discussion Forums</a></p><h1 id="վ-HᴗP-ի"><a href="#վ-HᴗP-ի" class="headerlink" title="վ HᴗP ի"></a>վ HᴗP ի</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IoT大杀器nRF52832&quot;&gt;&lt;a href=&quot;#IoT大杀器nRF52832&quot; class=&quot;headerlink&quot; title=&quot;IoT大杀器nRF52832&quot;&gt;&lt;/a&gt;IoT大杀器nRF52832&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;%E5%9F%BA%E4
      
    
    </summary>
    
      <category term="Maker" scheme="https://hanspond.github.io/categories/Maker/"/>
    
      <category term="Wireless Communication" scheme="https://hanspond.github.io/categories/Maker/Wireless-Communication/"/>
    
    
      <category term="Programming" scheme="https://hanspond.github.io/tags/Programming/"/>
    
      <category term="BLE" scheme="https://hanspond.github.io/tags/BLE/"/>
    
      <category term="Bluetooth" scheme="https://hanspond.github.io/tags/Bluetooth/"/>
    
      <category term="mbed" scheme="https://hanspond.github.io/tags/mbed/"/>
    
  </entry>
  
  <entry>
    <title>MacOS上键盘/鼠标控制应用的Swift语言开发笔记</title>
    <link href="https://hanspond.github.io/2018/02/21/MacOS%E4%B8%8A%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E5%BA%94%E7%94%A8%E7%9A%84Swift%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://hanspond.github.io/2018/02/21/MacOS上键盘鼠标控制应用的Swift语言开发笔记/</id>
    <published>2018-02-21T09:00:00.000Z</published>
    <updated>2018-02-21T11:09:03.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MacOS上键盘-鼠标控制应用的Swift语言开发笔记"><a href="#MacOS上键盘-鼠标控制应用的Swift语言开发笔记" class="headerlink" title="MacOS上键盘/鼠标控制应用的Swift语言开发笔记"></a>MacOS上键盘/鼠标控制应用的Swift语言开发笔记</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>继续在做小gadget，先学习基本操作。<br>这次需要实现的功能是程序控制键盘和鼠标，也就是人不需要碰键盘鼠标而键盘自动输入，鼠标自动移动点击的功能。</p><p>网上搜索了一下，Objective-C的实现例子倒是不少，可是基本找不到太多讲swift上面实现的例子，无奈自行摸索，在此总结一下。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>本功能应该属于Accessibility（辅助功能）的范畴，测试需要给予Xcode相应的操作权限。<br>打开【系统编好设置】，【安全性与隐私】，【隐私】里面勾选Xcode前面的方框。如果看不到Xcode的话手动添加。</p><h2 id="库和官方文件"><a href="#库和官方文件" class="headerlink" title="库和官方文件"></a>库和官方文件</h2><p>需要用到Core Graphics里面的</p><ul><li><a href="https://developer.apple.com/documentation/coregraphics/quartz_event_services" target="_blank" rel="noopener">Quartz Event Services | Apple Developer Documentation</a></li><li><a href="https://developer.apple.com/documentation/coregraphics/quartz_display_services" target="_blank" rel="noopener">Quartz Display Services | Apple Developer Documentation</a></li></ul><h2 id="按键事件控制键盘"><a href="#按键事件控制键盘" class="headerlink" title="按键事件控制键盘"></a>按键事件控制键盘</h2><p>首先定义所需要的按键事件，然后通过post方法让系统执行事件。<br>每一次按键需要先按下再离开，通过函数分别定义这两个操作。</p><h4 id="属性方面："><a href="#属性方面：" class="headerlink" title="属性方面："></a>属性方面：</h4><ul><li>这里的CGEventSourceStateID看了一下官方文件，分privateState，combinedSessionState和hidSystemState三种，这里选择最后一个，一般source定义为nil也可以。</li><li>virtualKey后面是需要的按键的代码，mac的英语键盘的话参考文末的一览表。</li><li>keyDown当然true是按下，false是松开了</li><li>tap后面是按键时候的鼠标位置</li></ul><pre><code class="lang-swift">//按下按键func keyboardKeyDown(key: CGKeyCode) {        let source = CGEventSource(stateID: CGEventSourceStateID.hidSystemState)        let event = CGEvent(keyboardEventSource: source, virtualKey: key, keyDown: true)         event?.post(tap: CGEventTapLocation.cghidEventTap)        print(&quot;key \(key) is down&quot;)    }//松开按键    func keyboardKeyUp(key: CGKeyCode) {        let source = CGEventSource(stateID: CGEventSourceStateID.hidSystemState)        let event = CGEvent(keyboardEventSource: source, virtualKey: key, keyDown: false)        event?.post(tap: CGEventTapLocation.cghidEventTap)        print(&quot;key \(key) is released&quot;)    }</code></pre><h4 id="按键例子"><a href="#按键例子" class="headerlink" title="按键例子"></a>按键例子</h4><p>比如说需要按下F5的话，调用上面两个函数就可以</p><pre><code class="lang-swift">keyboardKeyDown(key: 0x60) //0x60是F5功能键代码keyboardKeyUp(key: 0x60)</code></pre><h4 id="Command-C怎么办？"><a href="#Command-C怎么办？" class="headerlink" title="Command+C怎么办？"></a>Command+C怎么办？</h4><p>这时候加入<a href="https://developer.apple.com/documentation/coregraphics/cgeventflags" target="_blank" rel="noopener">CGEventFlags - Core Graphics | Apple Developer Documentation</a></p><pre><code class="lang-swift">let cmd_c_D = CGEventCreateKeyboardEvent(nil, 0x08, true); //0x08是C键代码 cmd-c downCGEventSetFlags(cmd_c_D, CGEventFlags.MaskCommand);CGEventPost(CGEventTapLocation.CGHIDEventTap, cmd-c-D);let cmd_c_U = CGEventCreateKeyboardEvent(nil, 0x08, false); // cmd-c upCGEventSetFlags(cmd_c_U, CGEventFlags.MaskCommand);CGEventPost(CGEventTapLocation.CGHIDEventTap, cmd_c_U);</code></pre><p>shift，control等都有相应的CGEventSetFlags</p><h2 id="鼠标控制"><a href="#鼠标控制" class="headerlink" title="鼠标控制"></a>鼠标控制</h2><h3 id="鼠标控制注意"><a href="#鼠标控制注意" class="headerlink" title="鼠标控制注意"></a>鼠标控制注意</h3><ul><li>移动鼠标和显示移动后的鼠标是不同的事件操作。</li><li>还有注意显示器的坐标轴原点不是左上角，而是左下角。留意别搞错y轴的方向了。</li></ul><h3 id="移动点击鼠标事件"><a href="#移动点击鼠标事件" class="headerlink" title="移动点击鼠标事件"></a>移动点击鼠标事件</h3><pre><code class="lang-swift">// 鼠标左键按下guard let mouseDown = CGEvent(mouseEventSource: nil,                        mouseType: .leftMouseDown,                        mouseCursorPosition: CGPoint(x: 200, y: 300),                        mouseButton: .left                        ) else {return}mouseDown?.post(tap: .cghidEventTap)// 鼠标左键抬起guard let mouseUp = CGEvent(mouseEventSource: nil,                      mouseType: .leftMouseUp,                      mouseCursorPosition: CGPoint(x: 200, y: 300),                      mouseButton: .left                      ) else {return}mouseUp?.post(tap: .cghidEventTap)</code></pre><p>属性一览表：<a href="https://developer.apple.com/documentation/coregraphics/cgeventtype" target="_blank" rel="noopener">CGEventType - Core Graphics | Apple Developer Documentation</a></p><p>只移动鼠标</p><pre><code class="lang-swift">guard let moveEvent = CGEvent(mouseEventSource: nil, mouseType: .mouseMoved,                       mouseCursorPosition: point, mouseButton: .left                       ) else {return}moveEvent?.post(tap: .cghidEventTap)</code></pre><h3 id="移动屏幕上面的鼠标图标"><a href="#移动屏幕上面的鼠标图标" class="headerlink" title="移动屏幕上面的鼠标图标"></a>移动屏幕上面的鼠标图标</h3><p>利用上面的事件移动鼠标之后，屏幕上的鼠标图标是不动的。需要再用下面操作才能看到鼠标的图标在屏幕上面移动了。</p><pre><code class="lang-swift">func CGDisplayMoveCursorToPoint(_ display: CGDirectDisplayID,                               _ point: CGPoint) -&gt; CGError</code></pre><h3 id="完整的鼠标移动函数"><a href="#完整的鼠标移动函数" class="headerlink" title="完整的鼠标移动函数"></a>完整的鼠标移动函数</h3><pre><code class="lang-swift">func moveMouse(_ dx:CGFloat , _ dy:CGFloat){  //先监控移动前鼠标位置  var mouseLoc = NSEvent.mouseLocation    mouseLoc.y = NSHeight(NSScreen.screens[0].frame) - mouseLoc.y;  //计算鼠标新位置  let newLoc = CGPoint(x: mouseLoc.x-CGFloat(dx), y: mouseLoc.y+CGFloat(dy))   print(&quot;moving \(dx) \(dy)&quot;)  CGDisplayMoveCursorToPoint(0, newLoc)    }</code></pre><h3 id="其他先留坑"><a href="#其他先留坑" class="headerlink" title="其他先留坑"></a>其他先留坑</h3><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h2 id="MouseType类型"><a href="#MouseType类型" class="headerlink" title="MouseType类型"></a>MouseType类型</h2><pre><code class="lang-swift">/* Constants that specify the different types of input events. */public enum CGEventType : UInt32 {    /* The null event. */    case null    /* Mouse events. */    case leftMouseDown    case leftMouseUp    case rightMouseDown    case rightMouseUp    case mouseMoved    case leftMouseDragged    case rightMouseDragged    /* Keyboard events. */    case keyDown    case keyUp    case flagsChanged    /* Specialized control devices. */    case scrollWheel    case tabletPointer    case tabletProximity    case otherMouseDown    case otherMouseUp    case otherMouseDragged    /* Out of band event types. These are delivered to the event tap callback       to notify it of unusual conditions that disable the event tap. */    case tapDisabledByTimeout    case tapDisabledByUserInput}</code></pre><h3 id="Mac的键盘代码一览"><a href="#Mac的键盘代码一览" class="headerlink" title="Mac的键盘代码一览"></a>Mac的键盘代码一览</h3><pre><code class="lang-swift">/* *  Summary: *    Virtual keycodes *   *  Discussion: *    These constants are the virtual keycodes defined originally in *    Inside Mac Volume V, pg. V-191. They identify physical keys on a *    keyboard. Those constants with &quot;ANSI&quot; in the name are labeled *    according to the key position on an ANSI-standard US keyboard. *    For example, kVK_ANSI_A indicates the virtual keycode for the key *    with the letter &#39;A&#39; in the US keyboard layout. Other keyboard *    layouts may have the &#39;A&#39; key label on a different physical key; *    in this case, pressing &#39;A&#39; will generate a different virtual *    keycode. */enum {  kVK_ANSI_A                    = 0x00,  kVK_ANSI_S                    = 0x01,  kVK_ANSI_D                    = 0x02,  kVK_ANSI_F                    = 0x03,  kVK_ANSI_H                    = 0x04,  kVK_ANSI_G                    = 0x05,  kVK_ANSI_Z                    = 0x06,  kVK_ANSI_X                    = 0x07,  kVK_ANSI_C                    = 0x08,  kVK_ANSI_V                    = 0x09,  kVK_ANSI_B                    = 0x0B,  kVK_ANSI_Q                    = 0x0C,  kVK_ANSI_W                    = 0x0D,  kVK_ANSI_E                    = 0x0E,  kVK_ANSI_R                    = 0x0F,  kVK_ANSI_Y                    = 0x10,  kVK_ANSI_T                    = 0x11,  kVK_ANSI_1                    = 0x12,  kVK_ANSI_2                    = 0x13,  kVK_ANSI_3                    = 0x14,  kVK_ANSI_4                    = 0x15,  kVK_ANSI_6                    = 0x16,  kVK_ANSI_5                    = 0x17,  kVK_ANSI_Equal                = 0x18,  kVK_ANSI_9                    = 0x19,  kVK_ANSI_7                    = 0x1A,  kVK_ANSI_Minus                = 0x1B,  kVK_ANSI_8                    = 0x1C,  kVK_ANSI_0                    = 0x1D,  kVK_ANSI_RightBracket         = 0x1E,  kVK_ANSI_O                    = 0x1F,  kVK_ANSI_U                    = 0x20,  kVK_ANSI_LeftBracket          = 0x21,  kVK_ANSI_I                    = 0x22,  kVK_ANSI_P                    = 0x23,  kVK_ANSI_L                    = 0x25,  kVK_ANSI_J                    = 0x26,  kVK_ANSI_Quote                = 0x27,  kVK_ANSI_K                    = 0x28,  kVK_ANSI_Semicolon            = 0x29,  kVK_ANSI_Backslash            = 0x2A,  kVK_ANSI_Comma                = 0x2B,  kVK_ANSI_Slash                = 0x2C,  kVK_ANSI_N                    = 0x2D,  kVK_ANSI_M                    = 0x2E,  kVK_ANSI_Period               = 0x2F,  kVK_ANSI_Grave                = 0x32,  kVK_ANSI_KeypadDecimal        = 0x41,  kVK_ANSI_KeypadMultiply       = 0x43,  kVK_ANSI_KeypadPlus           = 0x45,  kVK_ANSI_KeypadClear          = 0x47,  kVK_ANSI_KeypadDivide         = 0x4B,  kVK_ANSI_KeypadEnter          = 0x4C,  kVK_ANSI_KeypadMinus          = 0x4E,  kVK_ANSI_KeypadEquals         = 0x51,  kVK_ANSI_Keypad0              = 0x52,  kVK_ANSI_Keypad1              = 0x53,  kVK_ANSI_Keypad2              = 0x54,  kVK_ANSI_Keypad3              = 0x55,  kVK_ANSI_Keypad4              = 0x56,  kVK_ANSI_Keypad5              = 0x57,  kVK_ANSI_Keypad6              = 0x58,  kVK_ANSI_Keypad7              = 0x59,  kVK_ANSI_Keypad8              = 0x5B,  kVK_ANSI_Keypad9              = 0x5C};/* keycodes for keys that are independent of keyboard layout*/enum {  kVK_Return                    = 0x24,  kVK_Tab                       = 0x30,  kVK_Space                     = 0x31,  kVK_Delete                    = 0x33,  kVK_Escape                    = 0x35,  kVK_Command                   = 0x37,  kVK_Shift                     = 0x38,  kVK_CapsLock                  = 0x39,  kVK_Option                    = 0x3A,  kVK_Control                   = 0x3B,  kVK_RightShift                = 0x3C,  kVK_RightOption               = 0x3D,  kVK_RightControl              = 0x3E,  kVK_Function                  = 0x3F,  kVK_F17                       = 0x40,  kVK_VolumeUp                  = 0x48,  kVK_VolumeDown                = 0x49,  kVK_Mute                      = 0x4A,  kVK_F18                       = 0x4F,  kVK_F19                       = 0x50,  kVK_F20                       = 0x5A,  kVK_F5                        = 0x60,  kVK_F6                        = 0x61,  kVK_F7                        = 0x62,  kVK_F3                        = 0x63,  kVK_F8                        = 0x64,  kVK_F9                        = 0x65,  kVK_F11                       = 0x67,  kVK_F13                       = 0x69,  kVK_F16                       = 0x6A,  kVK_F14                       = 0x6B,  kVK_F10                       = 0x6D,  kVK_F12                       = 0x6F,  kVK_F15                       = 0x71,  kVK_Help                      = 0x72,  kVK_Home                      = 0x73,  kVK_PageUp                    = 0x74,  kVK_ForwardDelete             = 0x75,  kVK_F4                        = 0x76,  kVK_End                       = 0x77,  kVK_F2                        = 0x78,  kVK_PageDown                  = 0x79,  kVK_F1                        = 0x7A,  kVK_LeftArrow                 = 0x7B,  kVK_RightArrow                = 0x7C,  kVK_DownArrow                 = 0x7D,  kVK_UpArrow                   = 0x7E};</code></pre><h2 id="参考和其他注意事项："><a href="#参考和其他注意事项：" class="headerlink" title="参考和其他注意事项："></a>参考和其他注意事项：</h2><ul><li>触发用户授权注册系统辅助权限：<br><a href="http://ju.outofmemory.cn/entry/291238" target="_blank" rel="noopener">MacOS获取辅助功能权限控制鼠标点击事件 - 为程序员服务</a></li></ul><pre><code class="lang-swift">let opts = NSDictionary(object: kCFBooleanTrue,                        forKey: kAXTrustedCheckOptionPrompt.takeUnretainedValue() as NSString                        ) as CFDictionaryguard AXIsProcessTrustedWithOptions(opts) == true else { return }</code></pre><ul><li><p>鼠标控制的一个范例：<br><a href="http://zhihaozhang.github.io/2017/09/23/%E8%AE%A9iMac%E4%B8%8EMacBook%E9%AB%98%E6%95%88%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94mouseSync%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/" target="_blank" rel="noopener">让iMac与MacBook高效协同工作——mouseSync开发心得 · Zhihao’s Studio</a><br><a href="http://zhihaozhang.github.io/2017/09/29/mouseSyncII/" target="_blank" rel="noopener">mouseSync后续功能完善心得 · Zhihao’s Studio</a><br><a href="https://github.com/zhihaozhang/mouseSync" target="_blank" rel="noopener">GitHub - zhihaozhang/mouseSync: 两台Mac共用一个触控板Trackpad/鼠标mouse</a></p></li><li><p>OS TrackPad from other mobile devices:<br><a href="https://github.com/zhijie/trackpad" target="_blank" rel="noopener">GitHub - zhijie/trackpad: use your iphone or android as a trackpad for your mac/pc. make your smartphone smarter</a></p></li><li><p>CGKeyCode：<br><a href="https://stackoverflow.com/questions/3202629/where-can-i-find-a-list-of-mac-virtual-key-codes/16125341" target="_blank" rel="noopener">macos - Where can I find a list of Mac virtual key codes? - Stack Overflow</a></p></li><li><p><a href="https://stackoverflow.com/questions/2734117/simulating-mouse-input-programmatically-in-os-x" target="_blank" rel="noopener">macos - Simulating mouse input programmatically in OS X - Stack Overflow</a></p></li><li><p><a href="https://stackoverflow.com/questions/35274099/swift2-cgeventsetflags-with-multi-cgeventflags" target="_blank" rel="noopener">swift - Swift2: CGEventSetFlags with multi CGEventFlags - Stack Overflow</a></p></li><li><p><a href="https://stackoverflow.com/questions/10734349/simulate-keypress-for-system-wide-hotkeys" target="_blank" rel="noopener">macos - Simulate keypress for system wide hotkeys - Stack Overflow</a></p></li></ul><h1 id="վ-HᴗP-ի"><a href="#վ-HᴗP-ի" class="headerlink" title="վ HᴗP ի"></a>վ HᴗP ի</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MacOS上键盘-鼠标控制应用的Swift语言开发笔记&quot;&gt;&lt;a href=&quot;#MacOS上键盘-鼠标控制应用的Swift语言开发笔记&quot; class=&quot;headerlink&quot; title=&quot;MacOS上键盘/鼠标控制应用的Swift语言开发笔记&quot;&gt;&lt;/a&gt;MacOS
      
    
    </summary>
    
      <category term="Programming" scheme="https://hanspond.github.io/categories/Programming/"/>
    
      <category term="HID" scheme="https://hanspond.github.io/categories/Programming/HID/"/>
    
    
      <category term="MacOS" scheme="https://hanspond.github.io/tags/MacOS/"/>
    
      <category term="Programming" scheme="https://hanspond.github.io/tags/Programming/"/>
    
      <category term="Swift" scheme="https://hanspond.github.io/tags/Swift/"/>
    
      <category term="App Development" scheme="https://hanspond.github.io/tags/App-Development/"/>
    
      <category term="HID" scheme="https://hanspond.github.io/tags/HID/"/>
    
  </entry>
  
  <entry>
    <title>MacOS上 Bluetooth Low Energy/BLE 应用的Swift语言开发笔记</title>
    <link href="https://hanspond.github.io/2018/02/16/MacOS%E4%B8%8ABLE%E5%BA%94%E7%94%A8%E7%9A%84Swift%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://hanspond.github.io/2018/02/16/MacOS上BLE应用的Swift语言开发笔记/</id>
    <published>2018-02-16T03:00:00.000Z</published>
    <updated>2018-03-09T11:54:33.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>最近由于各种原因打算做一个小gadget，这个小玩具需要用到BLE和PC/MAC通讯。作为一枚程序开发完完全全的新手，中途自然碰壁无数。而且说真的，本来在电脑上面用BLE就是比较罕见的奇葩要求，又找不到随手可用的教（copy）例（paste），总结一些经验教训（code），以供后来人参考。</p><h2 id="2-BLE和各种蓝牙区别"><a href="#2-BLE和各种蓝牙区别" class="headerlink" title="2. BLE和各种蓝牙区别"></a>2. BLE和各种蓝牙区别</h2><p>首先要注意一下，BLE和以前普通标准的蓝牙不同！两者不通用！</p><p>现在常见的蓝牙技术大概有三种，加上新推出的5代：</p><ol><li>Bluetooth Basic Rate_Enhanced Data Rate 也就是 BR_EDR</li><li>Bluetooth Low Energy 也就是 BLE </li><li>Bluetooth Smart 和 Smart Ready 大致是一种企图融合上面两种制式的过渡技术<br><img src="995903.png" alt="Fig 1"></li><li>Bluetooth 5.0 是最新的规格。买了chip有空再弄。</li></ol><h2 id="3-BLE蓝牙协议和实际利用"><a href="#3-BLE蓝牙协议和实际利用" class="headerlink" title="3. BLE蓝牙协议和实际利用"></a>3. BLE蓝牙协议和实际利用</h2><h3 id="3-1-具体协议内容和连接方式"><a href="#3-1-具体协议内容和连接方式" class="headerlink" title="3.1 具体协议内容和连接方式"></a>3.1 具体协议内容和连接方式</h3><p>详情可以自行百度，或者看原文<br>协议和栈方面比较详细的介绍有：<br><a href="http://www.wowotech.net/bluetooth/bt_overview.html" target="_blank" rel="noopener">蓝牙协议分析(1)_基本概念</a><br><a href="http://www.wowotech.net/bluetooth/bt_protocol_arch.html" target="_blank" rel="noopener">蓝牙协议分析(2)_协议架构</a><br><a href="http://www.wowotech.net/bluetooth/ble_stack_overview.html" target="_blank" rel="noopener">蓝牙协议分析(3)_蓝牙低功耗(BLE)协议栈介绍</a><br>还有这个：<a href="http://blog.csdn.net/qq_21842557/article/details/50768283" target="_blank" rel="noopener">BLE低功耗蓝牙介绍 - CSDN博客</a></p><p>当然了解具体协议和内容是非常非常重要的，不过对于日常小型应用来说，我们知道怎么发送怎么接受信息就可以了。<br>重点就是理解下图的Services和Characteristics<br><img src="7EBM_V0saoBZwk5j-YhWJQ.png" alt="Fig 2"></p><p>举个例子，BLE栈就像一个超市，里面有各个部署区域（Services），比方说：</p><ul><li>蔬果区（HIDS/HID Service 人机交互服务）</li><li>熟食区（GLS/Glucose Service 血糖服务）</li><li>零食区（HRM/Heart Rate Monitor 心率监控服务 UUID=0x180D）</li></ul><p>而每个部署区域都有货架，比如零食区（HRM心率）里面就有的：</p><ul><li>巧克力架(Heart Rate Measurement, Value, UUID=0x2A37 心跳率)</li><li>饼干架(Heart Rate Sensor Location, Value, UUID=0x2A38 传感器位置)</li></ul><p>例如，你想买牛奶巧克力，那就先要跑去零食区（UUID=0x180D），然后找到巧克力货架（UUID=0x2A37），et Voila!</p><p>这个Services和Characteristics都是用UUID来标记，都是约定俗成的，只能跑去看GATT里面的定义。<br>也可以自行生成UUID：<a href="https://www.uuidgenerator.net" target="_blank" rel="noopener">Online UUID Generator</a><br>-（当然有人会问那你想搞个没有定义或者不符合定义的数据的通讯怎么办呢？有个做法是挂羊头卖狗肉，当然Central和Peripheral两头设定都要对得上。）-</p><h3 id="3-2-Central和Peripheral"><a href="#3-2-Central和Peripheral" class="headerlink" title="3.2 Central和Peripheral"></a>3.2 Central和Peripheral</h3><p>一般来说Central是读取信息的一方，Peripheral是提供信息的一方现在的情况的话电脑是Central了。<br><img src="CBDevices1_2x.png" alt="Fig 3"></p><h3 id="3-3-比较有用的测试道具"><a href="#3-3-比较有用的测试道具" class="headerlink" title="3.3 比较有用的测试道具"></a>3.3 比较有用的测试道具</h3><p>Mac上面有两个道具比较有用：LightBlue和PacketLogger<br><img src="68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f343139342f39613833633663392d323032332d316434652d363438622d6666333866313939613732382e706e67.png" alt="Fig 4"><br><img src="68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f343139342f30323735323234632d376238652d626432622d623333662d3435306230326639666634642e706e67.png" alt="Fig 5"></p><p>iOS上面有：LightBlue，nRF Connect，nRF Toolbox</p><h2 id="4-MacOS-BLE-App-Swift编程的注意点"><a href="#4-MacOS-BLE-App-Swift编程的注意点" class="headerlink" title="4. MacOS BLE App Swift编程的注意点"></a>4. MacOS BLE App Swift编程的注意点</h2><p> 其实iOS的BLE程序的代码差不多改改UI组件就可以在MacOS上面使用，但是在Xcode里面编程调试MacOS Swift代码需要注意几个不同之处</p><h3 id="4-1-XPC-connection-invalid"><a href="#4-1-XPC-connection-invalid" class="headerlink" title="4.1 XPC connection invalid"></a>4.1 XPC connection invalid</h3><ol><li>在MacOS的Xcode里面，打开沙盒（App Sandbox）里面的蓝牙<br>路径：target -&gt; Capabilities -&gt; App Sandbox -&gt; Hardware -&gt; Bluetooth<br><img src="AB70987E-ABC4-474D-A555-B065F1F953F3.jpg" alt="Fig 6"></li></ol><ol><li>info.plist 里面追加 Privacy - Bluetooth Peripheral Usage Description，Value随意<br><img src="68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f36373135332f34346263323431312d386330362d393462322d353837372d3936643239336565353336652e706e67.png" alt="Fig 7"></li></ol><p>好了，准备完成！现在可以开始写代码了。<br>使用的swift版本是4, MacOS是High Sierra 10.13.3</p><hr><h2 id="5-1-初始化"><a href="#5-1-初始化" class="headerlink" title="5.1 初始化"></a>5.1 初始化</h2><ul><li>导入库</li></ul><pre><code class="lang-swift">import CoreBluetooth</code></pre><ul><li>导入delegate</li></ul><pre><code class="lang-swift">class ViewController: NSViewController, CBCentralManagerDelegate,                         CBPeripheralDelegate {    }</code></pre><ul><li>实例化</li></ul><pre><code class="lang-swift">var MacCentralManager: CBCentralManager!var TargetPeripheral: CBPeripheral!var TargetCharacteristic: CBCharacteristic!</code></pre><ul><li>初始化启动</li></ul><pre><code class="lang-swift">MacCentralManager = CBCentralManager(delegate: self, queue: nil)</code></pre><ul><li>定义UUID之类</li></ul><pre><code class="lang-swift">let heartRateServiceCBUUID = CBUUID(string: &quot;0x180D&quot;)let UUID1 = CBUUID(string: &quot;2A37&quot;)    //这个UUID是心率数据的特征let UUID2 = CBUUID(string: &quot;2A38&quot;)    //这个UUID是心率传感器位置的特征</code></pre><h2 id="5-2-检查蓝牙设备状态并开启搜索-必做"><a href="#5-2-检查蓝牙设备状态并开启搜索-必做" class="headerlink" title="5.2 检查蓝牙设备状态并开启搜索(必做)"></a>5.2 检查蓝牙设备状态并开启搜索<em>(必做)</em></h2><p>每次启动了APP必须首先检查本机蓝牙设备的状态是否在正常运作，否则以后代码很可能报错<br><code>[CoreBluetooth] API MISUSE: &lt;CBCentralManager: 0x17426af00&gt; can only accept this command while in the powered on state</code></p><pre><code class="lang-swift">func centralManagerDidUpdateState(_ central: CBCentralManager) {//检查蓝牙设备是否有在更新        if central.state == CBManagerState.poweredOn {             print(&quot;did update:\(central.state)&quot;)            //蓝牙设备确实有反应了才开始搜索            central.scanForPeripherals(withServices: nil,                                       options: nil)            print(&quot;Start Scanning&quot;)   //调试用        } else {            //蓝牙设备没有更新的话，报告原因            print(&quot;BLE on this Mac is not ready&quot;)            switch central.state {            case .unknown:                print(&quot;蓝牙的central.state is .unknown&quot;)            case .resetting:                print(&quot;蓝牙的central.state is .resetting&quot;)            case .unsupported:                print(&quot;蓝牙的central.state is .unsupported&quot;)            case .unauthorized:                print(&quot;蓝牙的central.state is .unauthorized&quot;)            case .poweredOff:                print(&quot;蓝牙的central.state is .poweredOff&quot;)            case .poweredOn:                print(&quot;蓝牙的central.state is .poweredOn&quot;)             }        }    }</code></pre><h2 id="5-3-搜索目标BLE设备然后连接设备"><a href="#5-3-搜索目标BLE设备然后连接设备" class="headerlink" title="5.3 搜索目标BLE设备然后连接设备"></a>5.3 搜索目标BLE设备然后连接设备</h2><pre><code class="lang-swift">func centralManager(_ central: CBCentralManager,                        didDiscover peripheral: CBPeripheral,                        advertisementData: [String : Any],                        rssi RSSI: NSNumber) {        //陈列周围的BLE设备        print(&quot;BLE Device identified: \(peripheral)&quot;)        //寻找identifier代码含有P_UUID的周边设备        if peripheral.identifier.uuidString.contains(&quot;P_UUID&quot;){             TargetPeripheral = peripheral            TargetPeripheral.delegate = self              //初始化peripheral的delegate            MacCentralManager.stopScan()             MacCentralManager.connect(TargetPeripheral)   //连接该peripheral        }        print(&quot;\(peripheral) is connected&quot;)               //调试用输出    }</code></pre><h2 id="5-4-确认连接上了"><a href="#5-4-确认连接上了" class="headerlink" title="5.4 确认连接上了"></a>5.4 确认连接上了</h2><pre><code class="lang-swift">func centralManager(_ central: CBCentralManager, didConnect peripheral:                                 CBPeripheral) {    print(&quot;Connection Confirmed!&quot;)    TargetPeripheral.discoverServices([heartRateServiceCBUUID])    print(&quot;Target Service Confirmed!&quot;)}</code></pre><p>不执行这一步的话下面代码会出错</p><h2 id="5-5-搜索指定Services服务并陈列Characteristics特征"><a href="#5-5-搜索指定Services服务并陈列Characteristics特征" class="headerlink" title="5.5 搜索指定Services服务并陈列Characteristics特征"></a>5.5 搜索指定Services服务并陈列Characteristics特征</h2><pre><code class="lang-swift">var TargetService: CBService!   // 实例化一般放在前面func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {        guard let services = peripheral.services else { return }        for service in services {            print(service)            //陈列所有的service和旗下的characteristics            peripheral.discoverCharacteristics(nil, for: service)               //寻找指定UUID的服务            if service.uuid.uuidString.contains(&quot;UUID&quot;) {                 print(&quot;Identified TargetServices \(service.uuid.uuidString)&quot;)                TargetService = service as CBService              }        }    }</code></pre><h2 id="5-6-找出指定的characteristics特征并读取"><a href="#5-6-找出指定的characteristics特征并读取" class="headerlink" title="5.6 找出指定的characteristics特征并读取"></a>5.6 找出指定的characteristics特征并读取</h2><pre><code class="lang-swift">func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {        guard let characteristics = TargetService.characteristics else { return }        print(&quot;Existing Characteristics identified&quot;)    //调试用输出        for characteristic in characteristics {            print(characteristic)            //陈列所有read方式的特征            if characteristic.properties.contains(.read) {                print(&quot;\(characteristic.uuid): properties contains .read&quot;)                  //找到read方式的characteristics并读取                peripheral.readValue(for: characteristic)            }            //陈列所有notify方式的特征            if characteristic.properties.contains(.notify) {                print(&quot;\(characteristic.uuid): properties contains .notify&quot;)                  //找到notify方式的characteristics并读取                peripheral.setNotifyValue(true, for: characteristic)            }            //也可以找指定UUID的characteristic特征            if characteristic.properties.contains(&quot;UUID&quot;) {                print(&quot;\(characteristic.uuid): properties contains UUID&quot;)                  //找到指定UUID的特征然后下面采取read或者notify                peripheral.setNotifyValue(true, for: characteristic)                peripheral.readValue(for: characteristic)            }        }    }</code></pre><h2 id="5-7-监控Characteristics新数据并提取"><a href="#5-7-监控Characteristics新数据并提取" class="headerlink" title="5.7 监控Characteristics新数据并提取"></a>5.7 监控Characteristics新数据并提取</h2><pre><code class="lang-swift">func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic:                                  CBCharacteristic, error: Error?) {    switch characteristic.uuid {    case UUID1:        guard let characteristicData1 = characteristic.value        //这里的characteristicData1就是读取成功的数据啦！        //自由添加代码自己爱怎么操作就怎么操作    case UUID2:        guard let characteristicData2 = characteristic.value        //这里的characteristicData2就是读取成功的数据啦！        //自由添加代码自己爱怎么操作就怎么操作    default:        print(&quot;Unhandled Characteristic UUID: \(characteristic.uuid)&quot;)    }    }</code></pre><h2 id="5-8-写数据"><a href="#5-8-写数据" class="headerlink" title="5.8 写数据"></a>5.8 写数据</h2><pre><code class="lang-swift">TargetPeripheral.writeValue(dataToTrans, for:   WriteCharactistic, type:                                 CBCharacteristicWriteType.withResponse)</code></pre><p>type还有withoutResponse</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>以上介绍了MacOS连接BLE设备最简单的基本操作流程，利用以上代码基本可以进行初级的读写数据。<br>如有错误还请指出。</p><p>MacOS的代码例子有空再写~<br>iOS上面的比较好的GitHub例子：<a href="https://github.com/DennisMao/eswiftBLE" target="_blank" rel="noopener">https://github.com/DennisMao/eswiftBLE</a> a.k.a <a href="http://blog.csdn.net/RazilFelix/article/details/65491470" target="_blank" rel="noopener">【Mac/ios】Swift3.0 BLE开发 - RazilFelix的博客 - CSDN博客</a></p><h2 id="其他诸多参考"><a href="#其他诸多参考" class="headerlink" title="其他诸多参考"></a>其他诸多参考</h2><p>[1]<a href="https://www.amazon.co.jp/iOS×BLE-Core-Bluetoothプログラミング-堤-修一/dp/4883379736" target="_blank" rel="noopener">iOS×BLE Core Bluetoothプログラミング</a><br>[2]<a href="https://qiita.com/eKushida/items/def628e0eff6c106d467#_reference-dd6c73d57e1da38aa031" target="_blank" rel="noopener">iOS SwiftでBLEのサンプルを動かしてみる</a><br>[3]<a href="https://qiita.com/Kyomesuke3/items/6d898af9fdcce8fb5381" target="_blank" rel="noopener">macOS x mbed OS でBLE通信する方法</a><br>[4]<a href="https://www.raywenderlich.com/177848/core-bluetooth-tutorial-for-ios-heart-rate-monitor" target="_blank" rel="noopener">Core Bluetooth Tutorial for iOS: Heart Rate Monitor</a><br>[5]<a href="https://blanktar.jp/blog/2017/02/ios-swift-eddystone-url.html" target="_blank" rel="noopener">swift使ってEddystone-URLを受信するiOSアプリを作った - BlankTar</a><br>[6]<a href="http://blog.csdn.net/sky_2016/article/details/40981111" target="_blank" rel="noopener">iOS蓝牙之Introduction to Core Bluetooth: Building a Heart Rate Monitor（翻译） - CSDN博客</a><br>[7]<a href="https://qiita.com/moaible/items/84e5789342840d862305" target="_blank" rel="noopener">BLEのペリフェラルを今更実装してみた(iOS編)</a><br>[8]<a href="https://codeburst.io/getting-started-with-bluetooth-low-energy-on-ios-ada3090fc9cc" target="_blank" rel="noopener">Getting started with Bluetooth Low Energy on iOS</a><br>[9]<a href="https://developer.apple.com/jp/documentation/CoreBluetoothPG.pdf" target="_blank" rel="noopener">Core Bluetooth Programming Guide Apple</a></p><h1 id="վ-HᴗP-ի"><a href="#վ-HᴗP-ի" class="headerlink" title="վ HᴗP ի"></a>վ HᴗP ի</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;最近由于各种原因打算做一个小gadget，这个小玩具需要用到BLE和PC/MAC通讯。作为一枚程序开发完完全全的新手，中
      
    
    </summary>
    
      <category term="Programming" scheme="https://hanspond.github.io/categories/Programming/"/>
    
      <category term="Wireless Communication" scheme="https://hanspond.github.io/categories/Programming/Wireless-Communication/"/>
    
    
      <category term="MacOS" scheme="https://hanspond.github.io/tags/MacOS/"/>
    
      <category term="Programming" scheme="https://hanspond.github.io/tags/Programming/"/>
    
      <category term="BLE" scheme="https://hanspond.github.io/tags/BLE/"/>
    
      <category term="Swift" scheme="https://hanspond.github.io/tags/Swift/"/>
    
      <category term="Bluetooth" scheme="https://hanspond.github.io/tags/Bluetooth/"/>
    
      <category term="App Development" scheme="https://hanspond.github.io/tags/App-Development/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hanspond.github.io/2018/02/15/hello-world/"/>
    <id>https://hanspond.github.io/2018/02/15/hello-world/</id>
    <published>2018-02-15T03:00:00.000Z</published>
    <updated>2018-02-16T08:34:21.370Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="lang-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Arduino驱动错误的一般解决方法</title>
    <link href="https://hanspond.github.io/2018/01/27/Arduino%E9%A9%B1%E5%8A%A8%E9%94%99%E8%AF%AF%E7%9A%84%E4%B8%80%E8%88%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://hanspond.github.io/2018/01/27/Arduino驱动错误的一般解决方法/</id>
    <published>2018-01-27T03:00:00.000Z</published>
    <updated>2018-03-09T12:00:22.753Z</updated>
    
    <content type="html"><![CDATA[<p>Arduino系列和衍生版种类特别多，每个人的电脑配置也不一样。结果是经常板子到家之后，插上电脑发现无法识别。鉴于开发板的性质，退换申诉困难，客服又一般采取不理不睬的态度没有技术支持。</p><p>又能怎么办？只能靠自己呗。</p><h1 id="先排除其他原因"><a href="#先排除其他原因" class="headerlink" title="先排除其他原因"></a>先排除其他原因</h1><p>板子连接电脑没反应，首先打开设备管理器大概是下面这个样子，出现Unknown Device</p><p><img src="1.PNG" alt="Fig 1"></p><p>这时候一般操作是：</p><ol><li>排除特殊芯片，例如CH340，CP210等芯片，看一下板子是否装了这种芯片，百度搜索下载各自的驱动即可。                       </li><li>Arduino IDE里面可能需要安装相应的库，例如Arduino101，nodemcu就需要专用的库才能识别操作，IDE里面搜索下载即可。                                                                             </li><li>还不行有个碰运气的做法：可以先右键删除设备管理器里面的Unknown Device，拔下设备重插，windows会自动寻找重装驱动。<br> 这个做法有一定成功几率，也可以解决问题。也可以尝试一下删除重装Arduino IDE，不是绿色版的那个，exe安装版的IDE才稳妥。                                                </li><li>可以尝试手动选择驱动安装的inf文件。Unknown Device右键选择update driver，出来的界面选择Browse my computer for driver software，下一步的页面点击let me pick from a list of available drivers on my computer，下一步的页面双击选择Ports，然后出现的页面点击右下角的硬盘，去到arduino/drivers文件夹里面选择arduino.inf文件，再选择板子的型号，接下来全部下一步即可。</li></ol><h1 id="强行追加驱动"><a href="#强行追加驱动" class="headerlink" title="强行追加驱动"></a>强行追加驱动</h1><p>上面的第4步还是出错（一般是code28）的话，有可能是系统确实缺了某些预设的驱动文件。<br>这个时候打开C:\Windows\INF里面的setupapi.dev.log，拖到最下面，找一下前面带！！！符号的几行字</p><p><img src="2.PNG" alt="Fig 2"></p><p>例如上图的情况，DFROBOT的CurieNano （Arduino 101）的驱动出错情况</p><pre><code>!!!  flq:                     Source Media: SPFQOPERATION_ABORT (C:\WINDOWS\System32\DriverStore\FileRepository\usbser.inf_amd64_827db80716f312be\usbser.sys).  !!!  flq:                     Error 2: The system cannot find the file specified.</code></pre><p>意思就是C:\WINDOWS\System32\DriverStore\FileRepository\usbser.inf_amd64_827db80716f312be\usbser.sys这个文件找不到，所以出错了。<br>解决办法就是新建文件夹C:\WINDOWS\System32\DriverStore\FileRepository\usbser.inf_amd64_827db80716f312be，再从其他地方找到usbser.sys复制到这个文件夹，问题解决！QEF!</p><p>每个电脑情况不太一样，具体看setupapi.dev的记录操作即可。</p><h1 id="վ-HᴗP-ի"><a href="#վ-HᴗP-ի" class="headerlink" title="վ HᴗP ի"></a>վ HᴗP ի</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Arduino系列和衍生版种类特别多，每个人的电脑配置也不一样。结果是经常板子到家之后，插上电脑发现无法识别。鉴于开发板的性质，退换申诉困难，客服又一般采取不理不睬的态度没有技术支持。&lt;/p&gt;
&lt;p&gt;又能怎么办？只能靠自己呗。&lt;/p&gt;
&lt;h1 id=&quot;先排除其他原因&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Maker" scheme="https://hanspond.github.io/categories/Maker/"/>
    
    
      <category term="Arduino" scheme="https://hanspond.github.io/tags/Arduino/"/>
    
      <category term="driver" scheme="https://hanspond.github.io/tags/driver/"/>
    
      <category term="MacOS" scheme="https://hanspond.github.io/tags/MacOS/"/>
    
      <category term="Windows" scheme="https://hanspond.github.io/tags/Windows/"/>
    
      <category term="debug" scheme="https://hanspond.github.io/tags/debug/"/>
    
  </entry>
  
</feed>
