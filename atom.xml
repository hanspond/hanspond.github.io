<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>H_P-&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hanspond.github.io/"/>
  <updated>2018-02-20T13:17:23.133Z</updated>
  <id>https://hanspond.github.io/</id>
  
  <author>
    <name>$H_P?</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MacOS上 Bluetooth Low Energy/BLE 应用的Swift语言开发笔记</title>
    <link href="https://hanspond.github.io/2018/02/16/MacOS%E4%B8%8ABLE%E5%BA%94%E7%94%A8%E7%9A%84Swift%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://hanspond.github.io/2018/02/16/MacOS上BLE应用的Swift语言开发笔记/</id>
    <published>2018-02-16T03:00:00.000Z</published>
    <updated>2018-02-20T13:17:23.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>最近由于各种原因打算做一个小gadget，这个小玩具需要用到BLE和PC/MAC通讯。作为一枚程序开发完完全全的新手，中途自然碰壁无数。而且说真的，本来在电脑上面用BLE就是比较罕见的奇葩要求，又找不到随手可用的教（copy）例（paste），总结一些经验教训（code），以供后来人参考。</p><h2 id="2-BLE和各种蓝牙区别"><a href="#2-BLE和各种蓝牙区别" class="headerlink" title="2. BLE和各种蓝牙区别"></a>2. BLE和各种蓝牙区别</h2><p>首先要注意一下，BLE和以前普通标准的蓝牙不同！两者不通用！</p><p>现在常见的蓝牙技术大概有三种，加上新推出的5代：</p><ol><li>Bluetooth Basic Rate_Enhanced Data Rate 也就是 BR_EDR</li><li>Bluetooth Low Energy 也就是 BLE </li><li>Bluetooth Smart 和 Smart Ready 大致是一种企图融合上面两种制式的过渡技术<br><img src="/2018/02/16/MacOS上BLE应用的Swift语言开发笔记/995903.png" alt="Fig 1"></li><li>Bluetooth 5.0 是最新的规格。买了chip有空再弄。</li></ol><h2 id="3-BLE蓝牙协议和实际利用"><a href="#3-BLE蓝牙协议和实际利用" class="headerlink" title="3. BLE蓝牙协议和实际利用"></a>3. BLE蓝牙协议和实际利用</h2><h3 id="3-1-具体协议内容和连接方式"><a href="#3-1-具体协议内容和连接方式" class="headerlink" title="3.1 具体协议内容和连接方式"></a>3.1 具体协议内容和连接方式</h3><p>详情可以自行百度，或者看原文<br>协议和栈方面比较详细的介绍有：<br><a href="http://www.wowotech.net/bluetooth/bt_overview.html" target="_blank" rel="noopener">蓝牙协议分析(1)_基本概念</a><br><a href="http://www.wowotech.net/bluetooth/bt_protocol_arch.html" target="_blank" rel="noopener">蓝牙协议分析(2)_协议架构</a><br><a href="http://www.wowotech.net/bluetooth/ble_stack_overview.html" target="_blank" rel="noopener">蓝牙协议分析(3)_蓝牙低功耗(BLE)协议栈介绍</a><br>还有这个：<a href="http://blog.csdn.net/qq_21842557/article/details/50768283" target="_blank" rel="noopener">BLE低功耗蓝牙介绍 - CSDN博客</a></p><p>当然了解具体协议和内容是非常非常重要的，不过对于日常小型应用来说，我们知道怎么发送怎么接受信息就可以了。<br>重点就是理解下图的Services和Characteristics<br><img src="/2018/02/16/MacOS上BLE应用的Swift语言开发笔记/7EBM_V0saoBZwk5j-YhWJQ.png" alt="Fig 2"></p><p>举个例子，BLE栈就像一个超市，里面有各个部署区域（Services），比方说：</p><ul><li>蔬果区（HIDS/HID Service 人机交互服务）</li><li>熟食区（GLS/Glucose Service 血糖服务）</li><li>零食区（HRM/Heart Rate Monitor 心率监控服务 UUID=0x180D）</li></ul><p>而每个部署区域都有货架，比如零食区（HRM心率）里面就有的：</p><ul><li>巧克力架(Heart Rate Measurement, Value, UUID=0x2A37 心跳率)</li><li>饼干架(Heart Rate Sensor Location, Value, UUID=0x2A38 传感器位置)</li></ul><p>例如，你想买牛奶巧克力，那就先要跑去零食区（UUID=0x180D），然后找到巧克力货架（UUID=0x2A37），et Voila!</p><p>这个Services和Characteristics都是用UUID来标记，都是约定俗成的，只能跑去看GATT里面的定义，不支持自定义。<br>-（当然有人会问那你想搞个没有定义或者不符合定义的数据的通讯怎么办呢？有个做法是挂羊头卖狗肉，当然Central和Peripheral两头设定都要对得上。）-</p><h3 id="3-2-Central和Peripheral"><a href="#3-2-Central和Peripheral" class="headerlink" title="3.2 Central和Peripheral"></a>3.2 Central和Peripheral</h3><p>一般来说Central是读取信息的一方，Peripheral是提供信息的一方现在的情况的话电脑是Central了。<br><img src="/2018/02/16/MacOS上BLE应用的Swift语言开发笔记/CBDevices1_2x.png" alt="Fig 3"></p><h3 id="3-3-比较有用的测试道具"><a href="#3-3-比较有用的测试道具" class="headerlink" title="3.3 比较有用的测试道具"></a>3.3 比较有用的测试道具</h3><p>Mac上面有两个道具比较有用：LightBlue和PacketLogger<br><img src="/2018/02/16/MacOS上BLE应用的Swift语言开发笔记/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f343139342f39613833633663392d323032332d316434652d363438622d6666333866313939613732382e706e67.png" alt="Fig 4"><br><img src="/2018/02/16/MacOS上BLE应用的Swift语言开发笔记/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f343139342f30323735323234632d376238652d626432622d623333662d3435306230326639666634642e706e67.png" alt="Fig 5"></p><p>iOS上面有：LightBlue，nRF Connect，nRF Toolbox</p><h2 id="4-MacOS-BLE-App-Swift编程的注意点"><a href="#4-MacOS-BLE-App-Swift编程的注意点" class="headerlink" title="4. MacOS BLE App Swift编程的注意点"></a>4. MacOS BLE App Swift编程的注意点</h2><p> 其实iOS的BLE程序的代码差不多改改UI组件就可以在MacOS上面使用，但是在Xcode里面编程调试MacOS Swift代码需要注意几个不同之处</p><h3 id="4-1-XPC-connection-invalid"><a href="#4-1-XPC-connection-invalid" class="headerlink" title="4.1 XPC connection invalid"></a>4.1 XPC connection invalid</h3><ol><li>在MacOS的Xcode里面，打开沙盒（App Sandbox）里面的蓝牙<br>路径：target -&gt; Capabilities -&gt; App Sandbox -&gt; Hardware -&gt; Bluetooth<br><img src="/2018/02/16/MacOS上BLE应用的Swift语言开发笔记/AB70987E-ABC4-474D-A555-B065F1F953F3.jpg" alt="Fig 6"></li></ol><ol><li>info.plist 里面追加 Privacy - Bluetooth Peripheral Usage Description，Value随意<br><img src="/2018/02/16/MacOS上BLE应用的Swift语言开发笔记/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f36373135332f34346263323431312d386330362d393462322d353837372d3936643239336565353336652e706e67.png" alt="Fig 7"></li></ol><p>好了，准备完成！现在可以开始写代码了。<br>使用的swift版本是4, MacOS是High Sierra 10.13.3</p><hr><h2 id="5-1-初始化"><a href="#5-1-初始化" class="headerlink" title="5.1 初始化"></a>5.1 初始化</h2><ul><li>导入库</li></ul><pre><code class="swift">import CoreBluetooth</code></pre><ul><li>导入delegate</li></ul><pre><code class="swift">class ViewController: NSViewController, CBCentralManagerDelegate,                         CBPeripheralDelegate {    }</code></pre><ul><li>实例化</li></ul><pre><code class="swift">var MacCentralManager: CBCentralManager!var TargetPeripheral: CBPeripheral!var TargetCharacteristic: CBCharacteristic!</code></pre><ul><li>初始化启动</li></ul><pre><code class="swift">MacCentralManager = CBCentralManager(delegate: self, queue: nil)</code></pre><ul><li>定义UUID之类</li></ul><pre><code class="swift">let heartRateServiceCBUUID = CBUUID(string: &quot;0x180D&quot;)let UUID1 = CBUUID(string: &quot;2A37&quot;)    //这个UUID是心率数据的特征let UUID2 = CBUUID(string: &quot;2A38&quot;)    //这个UUID是心率传感器位置的特征</code></pre><h2 id="5-2-检查蓝牙设备状态并开启搜索-必做"><a href="#5-2-检查蓝牙设备状态并开启搜索-必做" class="headerlink" title="5.2 检查蓝牙设备状态并开启搜索(必做)"></a>5.2 检查蓝牙设备状态并开启搜索<em>(必做)</em></h2><p>每次启动了APP必须首先检查本机蓝牙设备的状态是否在正常运作，否则以后代码很可能报错<br><code>[CoreBluetooth] API MISUSE: &lt;CBCentralManager: 0x17426af00&gt; can only accept this command while in the powered on state</code></p><pre><code class="swift">func centralManagerDidUpdateState(_ central: CBCentralManager) {//检查蓝牙设备是否有在更新        if central.state == CBManagerState.poweredOn {             print(&quot;did update:\(central.state)&quot;)            //蓝牙设备确实有反应了才开始搜索            central.scanForPeripherals(withServices: nil,                                       options: nil)            print(&quot;Start Scanning&quot;)   //调试用        } else {            //蓝牙设备没有更新的话，报告原因            print(&quot;BLE on this Mac is not ready&quot;)            switch central.state {            case .unknown:                print(&quot;蓝牙的central.state is .unknown&quot;)            case .resetting:                print(&quot;蓝牙的central.state is .resetting&quot;)            case .unsupported:                print(&quot;蓝牙的central.state is .unsupported&quot;)            case .unauthorized:                print(&quot;蓝牙的central.state is .unauthorized&quot;)            case .poweredOff:                print(&quot;蓝牙的central.state is .poweredOff&quot;)            case .poweredOn:                print(&quot;蓝牙的central.state is .poweredOn&quot;)             }        }    }</code></pre><h2 id="5-3-搜索目标BLE设备然后连接设备"><a href="#5-3-搜索目标BLE设备然后连接设备" class="headerlink" title="5.3 搜索目标BLE设备然后连接设备"></a>5.3 搜索目标BLE设备然后连接设备</h2><pre><code class="swift">func centralManager(_ central: CBCentralManager,                        didDiscover peripheral: CBPeripheral,                        advertisementData: [String : Any],                        rssi RSSI: NSNumber) {        //陈列周围的BLE设备        print(&quot;BLE Device identified: \(peripheral)&quot;)        //寻找identifier代码含有P_UUID的周边设备        if peripheral.identifier.uuidString.contains(&quot;P_UUID&quot;){             TargetPeripheral = peripheral            TargetPeripheral.delegate = self              //初始化peripheral的delegate            MacCentralManager.stopScan()             MacCentralManager.connect(TargetPeripheral)   //连接该peripheral        }        print(&quot;\(peripheral) is connected&quot;)               //调试用输出    }</code></pre><h2 id="5-4-确认连接上了"><a href="#5-4-确认连接上了" class="headerlink" title="5.4 确认连接上了"></a>5.4 确认连接上了</h2><pre><code class="swift">func centralManager(_ central: CBCentralManager, didConnect peripheral:                                 CBPeripheral) {    print(&quot;Connection Confirmed!&quot;)    TargetPeripheral.discoverServices([heartRateServiceCBUUID])    print(&quot;Target Service Confirmed!&quot;)}</code></pre><p>不执行这一步的话下面代码会出错</p><h2 id="5-5-搜索指定Services服务并陈列Characteristics特征"><a href="#5-5-搜索指定Services服务并陈列Characteristics特征" class="headerlink" title="5.5 搜索指定Services服务并陈列Characteristics特征"></a>5.5 搜索指定Services服务并陈列Characteristics特征</h2><pre><code class="swift">var TargetService: CBService!   // 实例化一般放在前面func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {        guard let services = peripheral.services else { return }        for service in services {            print(service)            //陈列所有的service和旗下的characteristics            peripheral.discoverCharacteristics(nil, for: service)               //寻找指定UUID的服务            if service.uuid.uuidString.contains(&quot;UUID&quot;) {                 print(&quot;Identified TargetServices \(service.uuid.uuidString)&quot;)                TargetService = service as CBService              }        }    }</code></pre><h2 id="5-6-找出指定的characteristics特征并读取"><a href="#5-6-找出指定的characteristics特征并读取" class="headerlink" title="5.6 找出指定的characteristics特征并读取"></a>5.6 找出指定的characteristics特征并读取</h2><pre><code class="swift">func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {        guard let characteristics = TargetService.characteristics else { return }        print(&quot;Existing Characteristics identified&quot;)    //调试用输出        for characteristic in characteristics {            print(characteristic)            //陈列所有read方式的特征            if characteristic.properties.contains(.read) {                print(&quot;\(characteristic.uuid): properties contains .read&quot;)                  //找到read方式的characteristics并读取                peripheral.readValue(for: characteristic)            }            //陈列所有notify方式的特征            if characteristic.properties.contains(.notify) {                print(&quot;\(characteristic.uuid): properties contains .notify&quot;)                  //找到notify方式的characteristics并读取                peripheral.setNotifyValue(true, for: characteristic)            }            //也可以找指定UUID的characteristic特征            if characteristic.properties.contains(&quot;UUID&quot;) {                print(&quot;\(characteristic.uuid): properties contains UUID&quot;)                  //找到指定UUID的特征然后下面采取read或者notify                peripheral.setNotifyValue(true, for: characteristic)                peripheral.readValue(for: characteristic)            }        }    }</code></pre><h2 id="5-7-监控Characteristics新数据并提取"><a href="#5-7-监控Characteristics新数据并提取" class="headerlink" title="5.7 监控Characteristics新数据并提取"></a>5.7 监控Characteristics新数据并提取</h2><pre><code class="swift">func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic:                                  CBCharacteristic, error: Error?) {    switch characteristic.uuid {    case UUID1:        guard let characteristicData1 = characteristic.value        //这里的characteristicData1就是读取成功的数据啦！        //自由添加代码自己爱怎么操作就怎么操作    case UUID2:        guard let characteristicData2 = characteristic.value        //这里的characteristicData2就是读取成功的数据啦！        //自由添加代码自己爱怎么操作就怎么操作    default:        print(&quot;Unhandled Characteristic UUID: \(characteristic.uuid)&quot;)    }    }</code></pre><h2 id="5-8-写数据"><a href="#5-8-写数据" class="headerlink" title="5.8 写数据"></a>5.8 写数据</h2><pre><code class="swift">TargetPeripheral.writeValue(dataToTrans, for:   WriteCharactistic, type:                                 CBCharacteristicWriteType.withResponse)</code></pre><p>type还有withoutResponse</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>以上介绍了MacOS连接BLE设备最简单的基本操作流程，利用以上代码基本可以进行初级的读写数据。<br>如有错误还请指出。</p><p>MacOS的代码例子有空再写~<br>iOS上面的比较好的GitHub例子：<a href="https://github.com/DennisMao/eswiftBLE" target="_blank" rel="noopener">https://github.com/DennisMao/eswiftBLE</a> a.k.a <a href="http://blog.csdn.net/RazilFelix/article/details/65491470" target="_blank" rel="noopener">【Mac/ios】Swift3.0 BLE开发 - RazilFelix的博客 - CSDN博客</a></p><p>其他诸多参考<br>[1]iOS×BLE Core Bluetoothプログラミング<br>[2]<a href="https://qiita.com/eKushida/items/def628e0eff6c106d467#_reference-dd6c73d57e1da38aa031" target="_blank" rel="noopener">https://qiita.com/eKushida/items/def628e0eff6c106d467#_reference-dd6c73d57e1da38aa031</a><br>[3]<a href="https://qiita.com/Kyomesuke3/items/6d898af9fdcce8fb5381" target="_blank" rel="noopener">https://qiita.com/Kyomesuke3/items/6d898af9fdcce8fb5381</a><br>[4]<a href="https://www.raywenderlich.com/177848/core-bluetooth-tutorial-for-ios-heart-rate-monitor" target="_blank" rel="noopener">https://www.raywenderlich.com/177848/core-bluetooth-tutorial-for-ios-heart-rate-monitor</a><br>[5]<a href="https://blanktar.jp/blog/2017/02/ios-swift-eddystone-url.html" target="_blank" rel="noopener">swift使ってEddystone-URLを受信するiOSアプリを作った - BlankTar</a><br>[6]<a href="http://blog.csdn.net/sky_2016/article/details/40981111" target="_blank" rel="noopener">iOS蓝牙之Introduction to Core Bluetooth: Building a Heart Rate Monitor（翻译） - CSDN博客</a><br>[7]<a href="https://codeburst.io/getting-started-with-bluetooth-low-energy-on-ios-ada3090fc9cc" target="_blank" rel="noopener">https://codeburst.io/getting-started-with-bluetooth-low-energy-on-ios-ada3090fc9cc</a></p><h1 id="վ-HᴗP-ի"><a href="#վ-HᴗP-ի" class="headerlink" title="վ HᴗP ի"></a>վ HᴗP ի</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;最近由于各种原因打算做一个小gadget，这个小玩具需要用到BLE和PC/MAC通讯。作为一枚程序开发完完全全的新手，中
      
    
    </summary>
    
      <category term="WirelessCommunication" scheme="https://hanspond.github.io/categories/WirelessCommunication/"/>
    
    
      <category term="MacOS" scheme="https://hanspond.github.io/tags/MacOS/"/>
    
      <category term="BLE" scheme="https://hanspond.github.io/tags/BLE/"/>
    
      <category term="Swift" scheme="https://hanspond.github.io/tags/Swift/"/>
    
      <category term="Bluetooth" scheme="https://hanspond.github.io/tags/Bluetooth/"/>
    
      <category term="App Development" scheme="https://hanspond.github.io/tags/App-Development/"/>
    
      <category term="Programming" scheme="https://hanspond.github.io/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hanspond.github.io/2018/02/15/hello-world/"/>
    <id>https://hanspond.github.io/2018/02/15/hello-world/</id>
    <published>2018-02-15T03:00:00.000Z</published>
    <updated>2018-02-16T08:34:21.370Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Arduino驱动错误的一般解决方法</title>
    <link href="https://hanspond.github.io/2018/01/27/Arduino%E9%A9%B1%E5%8A%A8%E9%94%99%E8%AF%AF%E7%9A%84%E4%B8%80%E8%88%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://hanspond.github.io/2018/01/27/Arduino驱动错误的一般解决方法/</id>
    <published>2018-01-27T03:00:00.000Z</published>
    <updated>2018-02-20T11:23:21.847Z</updated>
    
    <content type="html"><![CDATA[<p>Arduino系列和衍生版种类特别多，每个人的电脑配置也不一样。结果是经常板子到家之后，插上电脑发现无法识别。鉴于开发板的性质，退换申诉困难，客服又一般采取不理不睬的态度没有技术支持。</p><p>又能怎么办？只能靠自己呗。</p><h1 id="先排除其他原因"><a href="#先排除其他原因" class="headerlink" title="先排除其他原因"></a>先排除其他原因</h1><p>板子连接电脑没反应，首先打开设备管理器大概是下面这个样子，出现Unknown Device</p><p><img src="/2018/01/27/Arduino驱动错误的一般解决方法/1.PNG" alt="Fig 1"></p><p>这时候一般操作是：</p><ol><li>排除特殊芯片，例如CH340，CP210等芯片，看一下板子是否装了这种芯片，百度搜索下载各自的驱动即可。                       </li><li>Arduino IDE里面可能需要安装相应的库，例如Arduino101，nodemcu就需要专用的库才能识别操作，IDE里面搜索下载即可。                                                                             </li><li>还不行有个碰运气的做法：可以先右键删除设备管理器里面的Unknown Device，拔下设备重插，windows会自动寻找重装驱动。<br> 这个做法有一定成功几率，也可以解决问题。也可以尝试一下删除重装Arduino IDE，不是绿色版的那个，exe安装版的IDE才稳妥。                                                </li><li>可以尝试手动选择驱动安装的inf文件。Unknown Device右键选择update driver，出来的界面选择Browse my computer for driver software，下一步的页面点击let me pick from a list of available drivers on my computer，下一步的页面双击选择Ports，然后出现的页面点击右下角的硬盘，去到arduino/drivers文件夹里面选择arduino.inf文件，再选择板子的型号，接下来全部下一步即可。</li></ol><h1 id="强行追加驱动"><a href="#强行追加驱动" class="headerlink" title="强行追加驱动"></a>强行追加驱动</h1><p>上面的第4步还是出错（一般是code28）的话，有可能是系统确实缺了某些预设的驱动文件。<br>这个时候打开C:\Windows\INF里面的setupapi.dev.log，拖到最下面，找一下前面带！！！符号的几行字</p><p><img src="/2018/01/27/Arduino驱动错误的一般解决方法/2.PNG" alt="Fig 2"></p><p>例如上图的情况，DFROBOT的CurieNano （Arduino 101）的驱动出错情况</p><pre><code>!!!  flq:                     Source Media: SPFQOPERATION_ABORT (C:\WINDOWS\System32\DriverStore\FileRepository\usbser.inf_amd64_827db80716f312be\usbser.sys).  !!!  flq:                     Error 2: The system cannot find the file specified.</code></pre><p>意思就是C:\WINDOWS\System32\DriverStore\FileRepository\usbser.inf_amd64_827db80716f312be\usbser.sys这个文件找不到，所以出错了。<br>解决办法就是新建文件夹C:\WINDOWS\System32\DriverStore\FileRepository\usbser.inf_amd64_827db80716f312be，再从其他地方找到usbser.sys复制到这个文件夹，问题解决！QEF!</p><p>每个电脑情况不太一样，具体看setupapi.dev的记录操作即可。</p><h1 id="վ-HᴗP-ի"><a href="#վ-HᴗP-ի" class="headerlink" title="վ HᴗP ի"></a>վ HᴗP ի</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Arduino系列和衍生版种类特别多，每个人的电脑配置也不一样。结果是经常板子到家之后，插上电脑发现无法识别。鉴于开发板的性质，退换申诉困难，客服又一般采取不理不睬的态度没有技术支持。&lt;/p&gt;
&lt;p&gt;又能怎么办？只能靠自己呗。&lt;/p&gt;
&lt;h1 id=&quot;先排除其他原因&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Maker" scheme="https://hanspond.github.io/categories/Maker/"/>
    
    
      <category term="Arduino" scheme="https://hanspond.github.io/tags/Arduino/"/>
    
      <category term="driver" scheme="https://hanspond.github.io/tags/driver/"/>
    
      <category term="MacOS" scheme="https://hanspond.github.io/tags/MacOS/"/>
    
      <category term="OS" scheme="https://hanspond.github.io/tags/OS/"/>
    
      <category term="windows" scheme="https://hanspond.github.io/tags/windows/"/>
    
      <category term="debug" scheme="https://hanspond.github.io/tags/debug/"/>
    
  </entry>
  
</feed>
